(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

require('./text');  // load text etc

var lastTime;

window.onload = function () {

    var w = window;
    var requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;

    var config = require('./config');
    var input = require('./input');
    var gameLoop = require('./gameLoop');
    var canvas = require('./canvas');
    var renderer = require('./renderer');


    function main() {
        var now = Date.now();
        var delta = now - lastTime;

        gameLoop.update(delta / 1000);
        gameLoop.render();

        lastTime = now;

        // Request to do this again ASAP
        requestAnimationFrame(main);
    }

    renderer.initialize();
    document.body.appendChild(renderer.getElement());

    if (window.addEventListener) {
        //window.addEventListener('resize', canvas.resizeCanvas, false);
        window.addEventListener('orientationchange', canvas.resizeCanvas, false);
    }
    input.registerEventHandlers();

    lastTime = Date.now();

    //canvas.resizeCanvas();
    main();
};
},{"./canvas":3,"./config":6,"./gameLoop":7,"./input":11,"./renderer":15,"./text":20}],2:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

var activeMap = module.exports = {};


var atlas = require('./map/atlas');
var player = require('./player');


activeMap.canMove = function canMove(dx, dy) {
    var map = atlas.maps[player.currentMap];

    var xc = player.position.x + dx;
    var yc = player.position.y + dy;

    return map.data[yc][xc] === 0;
};
},{"./map/atlas":12,"./player":14}],3:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 *
 * This module gives access to the HUD canvas for drawing status, character info, etc on top of the WebGL
 * Three.js renderer.
 *
 * Because Three.js will map this onto a plane geometry the size of the screen, there's no need for double
 * buffering to rescale the pixel art, etc.
 */

'use strict';


var config = require('./config');


//var bgCanvas = createNewCanvas(config.width, config.height);
//var bgCtx = bgCanvas.getContext("2d");

var canvas = createNewCanvas(config.width, config.height);
var ctx = canvas.getContext("2d");


module.exports = {
    clear: clear,
    //context: bgCtx,
    context: ctx,
    createNewCanvas: createNewCanvas,
    draw: draw,
    element: canvas,
    redraw: true,
    resizeCanvas: resizeCanvas
};

///////////////////////////////

function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    //bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
}


function createNewCanvas(width, height) {
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    return canvas;
}


function draw() {
    var w = config.width;// * config.scale;
    var h = config.height;// * config.scale;
    //ctx.drawImage(bgCanvas, 0, 0, w, h);
    ctx.drawImage(canvas, 0, 0, w, h);
}


// shamelessly ripped from heroine dusk code
function resizeCanvas() {
    var aspect_ratio = 4 / 3;

    var h, w;

    // the screen is wider than 4:3
    if (window.innerWidth * (3 / 4) > window.innerHeight) {
        h = window.innerHeight;
        w = h * aspect_ratio;
        config.scale = h / config.height;
    }
    // the screen is taller than 4:3
    else {
        w = window.innerWidth;
        h = w / aspect_ratio;
        config.scale = w / config.width;
    }

    config.scale = Math.floor(config.scale);
    //canvas.height = h;
    //canvas.width = w;
    canvas.height = config.height * config.scale;
    canvas.width = config.width * config.scale;

    module.exports.redraw = true;
    setNearestNeighbor();
}


function setNearestNeighbor() {
    ctx.imageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
    ctx.oImageSmoothingEnabled = false;
}

},{"./config":6}],4:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var canvas = require('./canvas');


/**
 * @description         Examines each pixel in the given image and changes all oldColor pixels to newColor, or if oldColor
 *                      is not specified then changes all non-black pixels to newColor
 * @param img
 * @param newColor      {Object} - {r, g, b}
 * @param oldColor      {Object} - {r, g, b}
 * @returns {String}    A DataURL that can be used as a .src for an Image
 */
function changeColor(img, newColor, oldColor) {
    newColor = newColor || {};
    oldColor = oldColor || {};

    var cnv = canvas.createNewCanvas(img.width, img.height);
    var ctx = cnv.getContext('2d');

    var nR = newColor.r || 0,
        nG = newColor.g || 0,
        nB = newColor.b || 0;

    var oR = oldColor.r,
        oG = oldColor.g,
        oB = oldColor.b;

    ctx.drawImage(img, 0, 0);

    // pull the entire image into an array of pixel data
    var imageData = ctx.getImageData(0, 0, img.width, img.height);

    // examine every pixel,
    // change any old rgb to the new-rgb
    for (var i = 0; i < imageData.data.length; i += 4) {
        if ((imageData.data[i] == oR &&
            imageData.data[i + 1] == oG &&
            imageData.data[i + 2] == oB
            ) || ((!oR && !oG && !oB) && imageData.data[i] > 0)) {

            imageData.data[i] = nR;
            imageData.data[i + 1] = nG;
            imageData.data[i + 2] = nB;
        }
    }
    // put the altered data back on the canvas
    ctx.putImageData(imageData, 0, 0);
    return cnv.toDataURL();
}

module.exports = changeColor;
},{"./canvas":3}],5:[function(require,module,exports){
/**
 * Created by john on 3/24/15.
 */

'use strict';


module.exports = {
    update: update,
    render: render
};


//var party = require('./characters/party');
var text = require('./text');
var input = require('./input');


var party = [
    {name: 'Char1', className: 'Fighter', level: 1, hp: 10, maxHp: 10},
    {name: 'Char2', className: 'Thief', level: 1, hp: 8, maxHp: 8},
    {name: 'Char2', className: 'Priest', level: 1, hp: 8, maxHp: 8},
    {name: 'Char2', className: 'Wizard', level: 1, hp: 4, maxHp: 4},
];


var widths = {
    name: 100,
    class: 70,
    level: 35,
    hp: 40
};


function update(delta, rect) {
    // no update yet
    for (var i = 0; i < party.length; i++) {
        var clickPos = {x: rect.x, y: rect.y + (i * 10), w: rect.w, h: 10};
        if (input.isClicked(clickPos)) {

        }
    }
}


function render(rect) {
    var margin = 7;

    var x = rect.x + margin;
    var y = rect.y + margin;

    text.drawText('Name', x, y, 'green');
    x += widths.name;

    text.drawText('Class', x, y, 'green');
    x += widths.class;

    text.drawText('Level', x, y, 'green');
    x += widths.level;

    text.drawText('HP', x, y, 'green');

    y += 12;
    for (var i = 0; i < party.length; i++) {
        drawCharacter(party[i], rect.x + margin, y + (i * 10));
    }
}


function drawCharacter(character, x, y) {
    var ox = x;
    var oy = y;

    text.drawText(character.name, x, y);
    x += widths.name;

    text.drawText(character.className, x, y);
    x += widths.class;

    text.drawText(character.level + '', x, y);
    x += widths.level;

    text.drawText(character.hp + '/' + character.maxHp, x, y);
}



},{"./input":11,"./text":20}],6:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';

var scaleFactor = 2;

var config = {
    fps: 60,
    scale: 1,
    width: 160 * scaleFactor,
    height: 120 * scaleFactor
};

module.exports = config;

},{}],7:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';

var gameState = require('./gameState');
var canvas = require('./canvas');
var renderer = require('./renderer');

var screens = {
    loading: require('./screens/loading'),
    //title: require('./screens/title'),
    //town: require('./screens/town'),
    dungeon: require('./screens/dungeon')
};

var states = gameState.states;


module.exports = {
    update: update,
    render: render
};

////////////////////////////////

function update(delta) {
    renderer.update(delta);

    switch (gameState.currentState) {

        case states.LOADING:
            screens.loading.update(delta);
            break;

        //case states.TITLE:
        //    screens.title.update(delta);
        //    break;
        //
        //case states.TOWN:
        //    screens.town.update(delta);
        //    break;

        case states.DUNGEON:
            screens.dungeon.update(delta);
            break;
    }
}


function render() {
    renderer.render();


    if (!canvas.redraw) return;
    canvas.clear();

    switch (gameState.currentState) {

        case states.LOADING:
            screens.loading.render();
            break;

        //case states.TITLE:
        //    screens.title.render();
        //    break;
        //
        //case states.TOWN:
        //    screens.town.render();
        //    break;

        case states.DUNGEON:
            screens.dungeon.render();
            break;

    }
    canvas.draw();
    canvas.redraw = false;
}
},{"./canvas":3,"./gameState":8,"./renderer":15,"./screens/dungeon":16,"./screens/loading":18}],8:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */



'use strict';

var canvas = require('./canvas');
var ctx = canvas.context;

var states = {
    LOADING: "loading",
    TITLE: "title",
    TOWN: "town",
    DUNGEON: "dungeon",
    BATTLE: "battle"
};


var gameState = {
    currentState: states.LOADING,
    setNextState: setNextState,
    states: states
};


module.exports = gameState;

//////////////////////////


function setNextState(state) {
    ctx.globalAlpha = 1;
    canvas.redraw = true;
    gameState.currentState = state;
}
},{"./canvas":3}],9:[function(require,module,exports){
/**
 * Created by john on 3/24/15.
 */

'use strict';

var hud = module.exports = {};


var images = require('./images');


hud.message = '';
},{"./images":10}],10:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var canvas = require('./canvas');
var ctx = canvas.context;

var totalImages = 9999;
var loadedImages = 0;
var loaded = false;

var images = {};


images.wallTexture = loadImage('walltexture');
images.floorTexture = loadImage('floortexture');

//images.title = loadImage('title');
//
images.borderUL = loadImage('textborder', {x: 0, y: 0, w: 16, h: 16});
images.borderU = loadImage('textborder', {x: 16, y: 0, w: 16, h: 16});
images.borderUR = loadImage('textborder', {x: 32, y: 0, w: 16, h: 16});
images.borderL = loadImage('textborder', {x: 0, y: 16, w: 16, h: 16});
images.borderM = loadImage('textborder', {x: 16, y: 16, w: 16, h: 16});
images.borderR = loadImage('textborder', {x: 32, y: 16, w: 16, h: 16});
images.borderBL = loadImage('textborder', {x: 0, y: 32, w: 16, h: 16});
images.borderB = loadImage('textborder', {x: 16, y: 32, w: 16, h: 16});
images.borderBR = loadImage('textborder', {x: 32, y: 32, w: 16, h: 16});
//
//images.room = loadImage('mapTiles', {x: 16, y: 0, w: 16, h: 16});
//images.visitedroom = loadImage('mapTiles', {x: 0, y: 0, w: 16, h: 16});
//images.currentPos = loadImage('mapTiles', {x: 22, y: 22, w: 4, h: 4});
//
//images.hCorridor = loadImage('mapTiles', {x: 32, y: 6, w: 4, h: 4});    // real width=16
//images.vCorridor = loadImage('mapTiles', {x: 6, y: 16, w: 4, h: 4});    // real height=16
//
//images.stairsUp = loadImage('mapTiles', {x: 32, y: 16, w: 16, h: 16});
//
images.skull = loadImage('skull', {x: 0, y: 0, w: 50, h: 50});
//
//
//images.tilesets = {};   // indexed by distance from player, 0=closest (tiles1), 4=furthest (tiles5)
//images.tilesets.dungeon = [
//    {
//        l: loadImage('tiles1', {x: 0, y: 0, w: 25, h: 140}),
//        r: loadImage('tiles1', {x: 175, y: 0, w: 25, h: 140}),
//        floor: loadImage('floors', {x: 0, y: 53, w: 200, h: 17}),
//        wall_l: loadImage('tiles1', {x: 175, y: 17, w: 25, h: 106}),
//        wall_r: loadImage('tiles1', {x: 0, y: 17, w: 25, h: 106}),     // fix this, create actual wall graphics
//        wall: loadImage('tiles1', {x: 25, y: 17, w: 150, h: 106})
//    }
//];


// get total number of images to make sure we've loaded everything
totalImages = Object.keys(images).length;
if (checkLoadComplete()) loaded = true;

module.exports = {
    drawBorder: drawBorder,
    drawImage: drawImage,
    getBorder: getBorder,
    images: images,
    isLoaded: function () {
        return loaded;
    },
    loadPct: function () {
        return loadedImages / totalImages;
    }
};

////////////////////////////////////////


function onLoad() {
    loadedImages++;
    if (checkLoadComplete()) {
        loaded = true;
    }
}

function checkLoadComplete() {
    return loadedImages >= totalImages;
}


function drawBorder(rect) {
    if (!loaded) return;
    var x = rect.x,
        y = rect.y,
        w = rect.w,
        h = rect.h;

    var borderSize = 16;

    var bottomRow = (y + h) - borderSize;
    var rightCol = (x + w) - borderSize;

    // take advantage of the fact that the border graphics are one color so we can stretch them

    drawImage('borderM', rect.x, rect.y, rect.w, rect.h);
    drawImage('borderU', rect.x, rect.y, rect.w, borderSize);
    drawImage('borderL', rect.x, rect.y, borderSize, rect.h);
    drawImage('borderR', rect.w - borderSize, rect.y, borderSize, rect.h);
    drawImage('borderB', rect.x, rect.h - borderSize, rect.w, borderSize);

    drawImage('borderUL', x, y);
    drawImage('borderUR', rightCol, y);
    drawImage('borderBL', x, bottomRow);
    drawImage('borderBR', rightCol, bottomRow);
}


function drawImage(image, x, y, w, h) {
    if (!loaded) return;

    var img = typeof(image) === 'object' ? image : images[image];
    w = w || img.sw;
    h = h || img.sh;


    if (img.sx !== undefined && img.sy !== undefined) {
        ctx.drawImage(img, img.sx, img.sy, img.sw, img.sh, x, y, w, h);
    } else {
        ctx.drawImage(img, x, y);
    }
}


function getBorder(rect) {
    var config = require('./config');

    console.log('getBorder');
    console.log(rect);

    var cnv = canvas.createNewCanvas(config.width, config.height);
    var context = cnv.getContext("2d");

    // switch the context around and draw to the new canvas, then switch it back
    ctx = context;
    var r2 = {x: 0, y: 0, w: rect.w, h: rect.h};
    drawBorder(r2);
    ctx = canvas.context;
    return cnv;
}


function loadImage(image, src) {
    var img = new Image();
    img.onload = onLoad;
    img.src = '/images/' + image + '.png';
    if (src) {
        img.sx = src.x;
        img.sy = src.y;
        img.sw = src.w;
        img.sh = src.h;
    }
    return img;
}



},{"./canvas":3,"./config":6}],11:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';

module.exports = {
    //clickPos: clickPos,
    //getMouseClick: getMouseClick,
    //isClicked: isClicked,
    //isMouseOver: isMouseOver,

    keyDown: isKeyDown,
    handleKey: function (key, processed) {
        processedKey[key] = processed;
    },

    //mousePos: mousePos,
    //mousePressed: mousePressed,

    processedKey: isKeyHandled,
    registerEventHandlers: registerEventHandlers
};


var config = require('./config');
var canvas = require('./canvas').element;
var utils = require('./utils');


var KEYCODE = {
    //UP: 38,
    //DOWN: 40,
    //LEFT: 37,
    //RIGHT: 39,
    UP: 87,
    DOWN: 83,
    LEFT: 65,
    RIGHT: 68,
    SPACE: 32
};
/*

 if (keyCode == 87) {
 camera.translateZ(-200);
 }
 if (keyCode == 68) {
 camera.rotation.y -= (Math.PI / 2);
 }
 if (keyCode == 83) {
 camera.translateZ(200);
 }
 if (keyCode == 65) {
 camera.rotation.y += (Math.PI / 2);
 }

 */

var mousePressed = {
    left: false,
    right: false
};

var keyDown = {
    left: false,
    right: false,
    up: false,
    down: false
};

var preventInput = {
    left: false,
    right: false
};

var processedKey = {
    left: false,
    right: false,
    up: false,
    down: false,
    action: false
};


var mousePos = {x: 0, y: 0};
var clickPos = null;


function handleMouseDown(evt) {
    evt.preventDefault();
    mousePressed.left = true;
    clickPos = clickCoord(evt);
}

function handleMouseUp(evt) {
    mousePressed.left = false;
    preventInput.left = false;
    clickPos = null;
}

function handleMouseOver(evt) {
    mousePos = clickCoord(evt);
}

function clickCoord(evt) {

    var canx;
    var cany;

    if (evt.pageX || evt.pageY) {
        canx = evt.pageX;
        cany = evt.pageY;
    }
    else {
        canx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        cany = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    canx -= canvas.offsetLeft;
    cany -= canvas.offsetTop;

    canx /= config.scale;
    cany /= config.scale;

    return {x: canx, y: cany};
}

/** Touch Handler **/

function handleTouchStart(evt) {
    evt.preventDefault();
    mousePressed.left = true;
    mousePos = touchCoord(evt);
}


function handleTouchEnd(evt) {
    mousePressed.left = false;
    preventInput.left = false;
}


function handleKeyDown(evt) {
    function setKey(key) {
        keyDown[key] = true;
        evt.preventDefault();
    }

    if (evt.keyCode == KEYCODE.UP) {
        //keyDown.up = true;
        setKey('up');
    }
    else if (evt.keyCode == KEYCODE.DOWN) {
        //keyDown.down = true;
        setKey('down');
    }
    else if (evt.keyCode == KEYCODE.LEFT) {
        //keyDown.left = true;
        setKey('left');
    }
    else if (evt.keyCode == KEYCODE.RIGHT) {
        //keyDown.right = true;
        setKey('right');
    }
    else if (evt.keyCode == KEYCODE.SPACE) {
        keyDown.action = true;
    }
}


function handleKeyUp(evt) {
    if (evt.keyCode == KEYCODE.UP) {
        keyDown.up = false;
        processedKey.up = false;
    }
    else if (evt.keyCode == KEYCODE.DOWN) {
        keyDown.down = false;
        processedKey.down = false;
    }
    else if (evt.keyCode == KEYCODE.LEFT) {
        keyDown.left = false;
        processedKey.left = false;
    }
    else if (evt.keyCode == KEYCODE.RIGHT) {
        keyDown.right = false;
        processedKey.right = false;
    }
    else if (evt.keyCode == KEYCODE.SPACE) {
        keyDown.action = false;
        processedKey.action = false;
    }
}


function registerEventHandlers() {
    if (window.addEventListener) {
        window.addEventListener('keydown', handleKeyDown, true);
        window.addEventListener('keyup', handleKeyUp, true);
        window.addEventListener('mousedown', handleMouseDown, true);
        window.addEventListener('mouseup', handleMouseUp, true);
        window.addEventListener('mousemove', handleMouseOver, true);
        window.addEventListener('touchstart', handleTouchStart, true);
        window.addEventListener('touchend', handleTouchEnd, true);
    }
}


/**
 * Returns true if the mouse is down within the specified rectangle
 * @param rect
 */
function isClicked(rect) {
    if (!rect) return false;
    if (preventInput.left) {
        console.log("preventinput");
        return false;
    }

    var clicked = mousePressed.left && isMouseOver(rect);
    if (clicked) {
        // make sure we don't process 2 clicks in 2 subsequent frames if the button is held down
        mousePressed.left = false;
    }
    return clicked;
}


function getMouseClick() {
    if (preventInput.left) return false;

    var clicked = mousePressed.left;
    if (clicked) {
        mousePressed.left = false;
        return clickPos;
    }
    return null;
}


function touchCoord(evt) {
    var canx = evt.touches[0].pageX;
    var cany = evt.touches[0].pageY;

    canx -= canvas.offsetLeft;
    cany -= canvas.offsetTop;

    canx /= config.scale;
    cany /= config.scale;

    return {x: canx, y: cany};
}


function isMouseOver(rect) {
    if (!rect) return false;
    return utils.isWithin(mousePos, rect);
}

function isKeyDown(key) {
    return keyDown[key];
}

function isKeyHandled(key) {
    return processedKey[key];
}


},{"./canvas":3,"./config":6,"./utils":21}],12:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

var atlas = module.exports = {};


var map2 = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1],
    [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1],
    [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
];


var maps = [
    {
        name: 'Starting map',
        data: map2,
        //rooms: initialize(map),
        ////startRoom: {x: 2, y: 2},
        startRoom: {x: 0, y: 3},
        maxEncounterChance: 0.6
    }
];


atlas.maps = maps;

},{}],13:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var textureCount = 0;
var textures = {
    wall: THREE.ImageUtils.loadTexture('/images/walltexture.png', {}, function () {
        textureCount++;
    }),
    floor: THREE.ImageUtils.loadTexture('/images/floortexture.png', {}, function () {
        textureCount++;
    })
};

module.exports = {
    loadTextures: loadTextures,
    getMapGeometry: getMapGeometry,
    getMapMesh: getMapMesh
};


function loadTextures() {
    return (textureCount === Object.keys(textures).length);
}


function transx(geo, n) {
    for (var i = 0; i < geo.vertices.length; i++) {
        geo.vertices[i].x += n;
    }
}

/**
 * Translate all points in a geometry `n` units in the z direction.
 */
function transz(geo, n) {
    for (var i = 0; i < geo.vertices.length; i++) {
        geo.vertices[i].z += n;
    }
}


function getMapGeometry(map) {
    return {
        mesh: getMapMesh(map),
        floor: getFloor(map)
    };
}

function getMapMesh(map) {
    var geometry, material, mesh;
    var img = textures.wall;
    img.minFilter = THREE.NearestFilter;
    img.magFilter = THREE.NearestFilter;


    geometry = new THREE.BoxGeometry(200, 200, 200);
    material = new THREE.MeshLambertMaterial({color: 0xaabbaa, wireframe: false, map: img});


    for (var j = 0; j < map.length; j++) {
        for (var i = 0; i < map[j].length; i++) {

            if (map[j][i] === 1) {
                var tmp = new THREE.BoxGeometry(200, 200, 200);
                transx(tmp, i * 200);
                transz(tmp, j * 200);
                console.log('i=' + i + ', j=' + j);

                geometry.merge(tmp);
            }

        }
    }

    mesh = new THREE.Mesh(geometry, material);
    return mesh;
}


function getFloor(map) {

    var width = map[0].length;
    var height = map.length;
    var cellSize = 200;

    var texture = textures.floor;
    texture.minFilter = THREE.NearestFilter;
    texture.magFilter = THREE.NearestFilter;

    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    texture.repeat.set(width * 2, height * 2);
    texture.needsUpdate = true;

    var material = new THREE.MeshPhongMaterial({map: texture, doubleSided: true, side: THREE.DoubleSide});
    var geometryPlane = new THREE.PlaneBufferGeometry(width * 2 * cellSize, height * 2 * cellSize);
    var plane = new THREE.Mesh(geometryPlane, material);

    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -100;    // center is at 0, height is 200
    plane.position.x = 0;
    plane.position.z = 0;

    return plane;
}
},{}],14:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var player = module.exports = {
    currentMap: 0,
    direction: 0,
    flags: []
};


var states = {
        MOVING: 0,
        TURNING: 1,
        INPUT: 2,
        NO_MOVE: 3
    },
    currentState = states.INPUT;


player.direction = Math.PI;
player.hasFlag = hasFlag;
player.position = {x: 3, y: 3};
player.states = states;

player.getState = function getState() {
    return currentState;
};
player.setState = function setState(state) {
    currentState = state;
};


function hasFlag(flag) {
    return player.flags.indexOf(flag) >= 0;
}

},{}],15:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 *
 * This module renders the view using Three.js
 */

'use strict';

var viewRenderer = module.exports = {
    'getElement': function () {
        return domElement;
    },
    'initialize': initialize,
    'initializeMap': initializeMap,
    'render': render,
    'update': update
};


viewRenderer.updateHud = function updateHud() {
    cnvText.needsUpdate = true;
};


var atlas = require('./map/atlas'),
    canvas = require('./canvas'),
    config = require('./config'),
    player = require('./player');


var cnvText;


var mapGeometry = require('./map/mapGeometry');
var hudMesh;
var scene, hudScene;
var camera, hudCam;
var renderer;
var domElement;
var playerLight;

var tileSize = 200,
    WIDTH = config.width,
    HEIGHT = config.height;


function initialize() {

    var scale = Math.floor(window.innerHeight / HEIGHT);    // scale to the available vertical space

    var wWidth = WIDTH * scale,
        wHeight = HEIGHT * scale,
        aspect = wWidth / wHeight;

    var context = canvas.context;

    context.fillStyle = 'rgb(100,50,150)';
    context.fillStyle = 'rgb(50, 50, 75)';
    //context.fillRect(5, 180, 310, 60);

    context.fillStyle = 'rgb(250, 50, 200)';
    context.fillRect(3, 80, 1, 5);


    cnvText = new THREE.Texture(canvas.element);
    cnvText.needsUpdate = true;
    cnvText.minFilter = THREE.NearestFilter;
    cnvText.magFilter = THREE.NearestFilter;


    scene = new THREE.Scene();
    hudScene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(80, aspect, 1, 10000);
    camera.position.y = -20;

    var width = wWidth;
    var height = wHeight;

    hudCam = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 10000);
    hudCam.position.z = 100;

    var planeGeom = new THREE.PlaneBufferGeometry(wWidth, wHeight);
    var textMater = new THREE.MeshBasicMaterial({
        map: cnvText,
        color: 0xffffff,
        transparent: true
    });


    hudMesh = new THREE.Mesh(planeGeom, textMater);
    hudMesh.lookAt(hudCam.position); // Rotate the mesh so the face is fully visible by the camera
    hudScene.add(hudMesh);

    renderer = new THREE.WebGLRenderer({antialiasing: false});


    renderer.setSize(wWidth, wHeight);
    renderer.setClearColor(0x0088FF, 1);
    renderer.autoClear = false;

    domElement = renderer.domElement;
}

function initializeMap() {
    var geometry = mapGeometry.getMapGeometry(atlas.maps[0].data);
    var mesh = geometry.mesh;
    var floor = geometry.floor;
    scene.add(mesh);
    scene.add(floor);


    playerLight = new THREE.PointLight(0xaaaaaa);
    playerLight.castShadow = false;
    playerLight.shadowMapWidth = 128;
    playerLight.shadowMapHeight = 128;
    playerLight.shadowCameraNear = 1;
    playerLight.shadowCameraFar = 100; //XXX: That should be far enough.
    playerLight.shadowCameraFov = 90;
    playerLight.shadowDarkness = 0.75; //XXX: Can change later...
    playerLight.intensity = 2.5;
    //playerLight.exponent = 20;
    playerLight.angle = Math.PI / 3;
    playerLight.distance = 200 * 10;

    //scene.add(playerLight);

    scene.add(camera);
    camera.add(playerLight);

    renderer.render(scene, camera);
    renderer.render(hudScene, hudCam);

}


function update(delta) {
    camera.rotation.y = player.direction;
    camera.position.z = tileSize * player.position.y;   // z-coord: fwd/back
    camera.position.x = tileSize * player.position.x;   // x-coord: left/right
}


function render() {

    renderer.render(scene, camera);
    renderer.render(hudScene, hudCam);
}
},{"./canvas":3,"./config":6,"./map/atlas":12,"./map/mapGeometry":13,"./player":14}],16:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';

var dungeon = module.exports = {};

var canvas = require('../../canvas'),
    config = require('../../config'),
    hud = require('../../hud'),
    input = require('../../input'),
    movement = require('./movement'),
    renderer = require('../../renderer'),
    text = require('../../text');

var charDisplay = require('../../characterDisplay');

/**
 * @description     Updates each frame
 */
dungeon.update = function update(delta) {
    var keyPressed = movement.processKeys();
    if (keyPressed && hud.message) {
        hud.message = "";
        canvas.redraw = true;
    }
    movement.update(delta, onMoveComplete);
};

/**
 * @description     Renders the view
 */
dungeon.render = function render() {

    // render entire view here

    //text.drawText('random number=' + Math.random(), 60, 60);
    //text.drawCentered('You are walking around in a maze.', 10);

    if (hud.message) {
        text.drawCentered(hud.message, 10);
    }

    charDisplay.render({x: 5, y: 240 - 65, w: 310, h: 60});

    renderer.updateHud();
};


function onMoveComplete(moved) {

    if (!moved) {
        hud.message = "There is a wall there!";
    }

    canvas.redraw = true;
}
},{"../../canvas":3,"../../characterDisplay":5,"../../config":6,"../../hud":9,"../../input":11,"../../renderer":15,"../../text":20,"./movement":17}],17:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var movement = module.exports = {};

var activeMap = require('../../activeMap'),
    input = require('../../input'),
    player = require('../../player'),
    sounds = require('../../sounds'),
    util = require('../../utils');


var keys = {left: false, right: false, up: false, down: false};

var turnTo = {
        from: 0,
        to: 0,
        dir: 0
    },
    walkTo = {
        from: 0,
        to: 0,
        dir: 0
    };


movement.processKeys = processKeys;
movement.update = update;


function processKeys() {

    keys = {
        left: false, right: false, up: false, down: false
    };
    if (player.getState() === player.states.INPUT) {
        var keyPressed = false;
        for (var key in keys) {
            if (keys.hasOwnProperty(key)) {

                if (input.keyDown(key)) {

                    if (!input.processedKey(key)) {
                        input.handleKey(key, true);

                        keys[key] = true;
                        keyPressed = true;
                        break;
                    }
                }
            }
        }

        return keyPressed;
    }
    return false;
}

function update(delta, moveCompleteCallback) {

    var vect;
    switch (player.getState()) {

        case player.states.INPUT:

            if (keys.left) {

                player.direction -= (Math.PI * 2);
                turnTo = {
                    from: player.direction,
                    to: (player.direction + (Math.PI / 2)) % (2 * Math.PI),
                    dir: -1
                };

            } else if (keys.right) {
                player.direction += (Math.PI * 2);  // so that our calculations for delta etc still work
                turnTo = {
                    from: player.direction,
                    to: (player.direction - (Math.PI / 2)) % (2 * Math.PI),
                    dir: 1
                };

            } else if (keys.up) {

                vect = {
                    x: Math.round(Math.sin(player.direction % (2 * Math.PI))) * -1,
                    y: Math.round(Math.cos(player.direction % (2 * Math.PI))) * -1
                };

                walkTo = {
                    from: {x: player.position.x, y: player.position.y},
                    to: {x: player.position.x + vect.x, y: player.position.y + vect.y},
                    dir: vect
                };


            } else if (keys.down) {

                vect = {
                    x: Math.round(Math.sin(player.direction % (2 * Math.PI))),
                    y: Math.round(Math.cos(player.direction % (2 * Math.PI)))
                };

                walkTo = {
                    from: {x: player.position.x, y: player.position.y},
                    to: {x: player.position.x + vect.x, y: player.position.y + vect.y},
                    dir: vect
                };

            }

            if (turnTo.from !== turnTo.to) {
                sounds.playSound('MOVE');
                player.setState(player.states.TURNING);

            } else if (walkTo.from !== walkTo.to) {

                if (activeMap.canMove(walkTo.dir.x, walkTo.dir.y)) {
                    sounds.playSound('MOVE');
                    player.setState(player.states.MOVING);

                } else {

                    sounds.playSound('NO_MOVE');
                    walkTo = {from: 0, to: 0, dir: 0};

                    // we can't move here, maybe do an action
                    moveCompleteCallback(false);
                }

            }

            break;

        case player.states.TURNING:

            player.direction -= (delta * (turnTo.dir) * 3);
            player.direction = player.direction % (Math.PI * 2);

            if (reachedDestination(turnTo.from, turnTo.to, player.direction)) {

                input.handleKey('left', false);
                input.handleKey('right', false);

                player.setState(player.states.INPUT);
                player.direction = turnTo.to;
                turnTo = {from: 0, to: 0, dir: 0};
            }

            break;

        case player.states.MOVING:

            player.position.x += (delta * 2 * walkTo.dir.x);
            player.position.y += (delta * 2 * walkTo.dir.y);

            var reachedX = reachedDestination(walkTo.from.x, walkTo.to.x, player.position.x);
            var reachedY = reachedDestination(walkTo.from.y, walkTo.to.y, player.position.y);

            if (reachedX && reachedY) {

                input.handleKey('up', false);
                input.handleKey('down', false);

                player.setState(player.states.INPUT);
                player.position.x = walkTo.to.x;
                player.position.y = walkTo.to.y;
                walkTo = {from: 0, to: 0, dir: 0};

                // we moved somewhere so maybe take an action
                moveCompleteCallback(true);
            }

            break;
    }
}


function reachedDestination(from, to, current) {

    if (from < to) {

        if (current >= to) {
            return true;
        }

    } else if (from > to) {

        if (current <= to) {
            return true;
        }

    } else {
        return true;
    }

    return false;
}
},{"../../activeMap":2,"../../input":11,"../../player":14,"../../sounds":19,"../../utils":21}],18:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var text = require('../text');
var images = require('../images');
var gameState = require('../gameState');
var mapGeometry = require('../map/mapGeometry');
var renderer = require('../renderer');


module.exports = {
    update: update,
    render: render
};


/////////////////


function render() {
    text.drawText('Loading...' + images.loadPct(), 100, 100);
}


function update(delta) {
    if (text.loaded && images.isLoaded() && mapGeometry.loadTextures()) {
        renderer.initializeMap();
        gameState.setNextState(gameState.states.DUNGEON);
    }
}
},{"../gameState":8,"../images":10,"../map/mapGeometry":13,"../renderer":15,"../text":20}],19:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var sounds = {
    MOVE: loadSound('walking', 0.5),
    NO_MOVE: loadSound('nomove'),
    START_BATTLE: loadSound('startbattle2')
};


module.exports = {
    fx: sounds,
    playSound: playSound
};


/////////////////////////////

function loadSound(sound, volume) {
    var snd = new Audio('/sounds/' + sound + '.wav');
    snd.volume = volume || 1.0;
    return snd;
}


function playSound(sound) {
    try {
        sounds[sound].currentTime = 0;
        sounds[sound].play();
    }
    catch (err) {
        // do something when sound doesn't play?
        console.log(err);
    }
}
},{}],20:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';


var textExport = {
    drawCentered: drawCentered,
    drawText: drawText,
    loaded: false,
    setCursor: setCursor,
    textWidth: textWidth
};

module.exports = textExport;


var canvas = require('./canvas'),
    changeColor = require('./changeColor'),
    config = require('./config'),
    utils = require('./utils');


var ctx = canvas.context;

var dataLoaded = false,
    imageLoaded = false,
    lineHeight = 0,
    data = null,
    fontName = 'roses',
    fontImg = new Image(),
    fontCache = {},
    fontColors = {
        'default': fontImg,
        'red': new Image(),
        'green': new Image()
    };


/**
 * The position where the text will be drawn
 * @type {{x: number, y: number}}
 */
var cursor = {x: 0, y: 0};


loadFontImage(fontImg);
loadFont();


////////////////////////////////////////////////


/**
 * Draws the glyph indicated by the code.
 * @param code
 * @returns {Number} The number of pixels to advance in the x-direction.
 */
function drawGlyph(code, color) {
    if (!textExport.loaded) return 0;

    color = color || 'default';

    var character = fontCache[code].char;

    var dst = utils.scaleRect({
        x: cursor.x + character.xoffset,
        y: cursor.y + character.yoffset,
        w: character.width,
        h: character.height
    }, config.scale);

    var src = {x: character.x, y: character.y, w: character.width, h: character.height};

    ctx.drawImage(fontColors[color], src.x, src.y, src.w, src.h, dst.x, dst.y, dst.w, dst.h);

    return character.xadvance; // to advance the cursor
}


/**
 * Draws a string of text at the given coordinates.
 * @param text
 * @param x
 * @param y
 */
function drawText(text, x, y, color) {
    x = Math.round(x);
    y = Math.round(y);
    color = color || 'default';

    setCursor(x, y);

    text = text || '';
    for (var i = 0; i < text.length; i++) {
        var code = text.charCodeAt(i);
        cursor.x += drawGlyph(code, color);
    }
}


function drawCentered(text, y) {
    if (!textExport.loaded) return;

    var tw = textWidth(text);
    var x = Math.floor((config.width / 2) - (tw / 2));
    drawText(text, x, y, 'red');
}


function loadFontImage(fontImg) {
    fontImg.src = "/fontImage/" + fontName;
    fontImg.onload = function () {

        // original font color: 240, 221, 178: #F0DDB2
        // 252 234 199

        /*  assign color changes here */
        fontColors.red.src = changeColor(fontImg, {r: 200, g: 50, b: 50}, {r: 252, g: 234, b: 199});
        fontColors.green.src = changeColor(fontImg, {r: 50, g: 200, b: 50}, {r: 252, g: 234, b: 199});

        imageLoaded = true;
        textExport.loaded = imageLoaded && dataLoaded;
        console.log(textExport.loaded);
    };
}


function loadFont() {
    var oReq = new XMLHttpRequest();
    oReq.onload = function () {
        data = JSON.parse(this.responseText);

        lineHeight = data.common.lineHeight;

        for (var i = 0; i < data.chars.length; i++) {
            fontCache[data.chars[i].id] = {
                char: data.chars[i],
                kerning: {}
            };
        }
        for (var j = 0; j < data.kernings.length; j++) {
            var kern = data.kernings[j];
            var char = fontCache[kern.first];
            if (char) {
                char.kerning[kern.second] = kern.amount;
            } else {
                console.log(kern.first);
            }
        }

        dataLoaded = true;
        textExport.loaded = imageLoaded && dataLoaded;
        console.log(textExport.loaded);
    };
    oReq.open("get", "/font/" + fontName, true);
    oReq.send();
}


/**
 * Moves the cursor to the indicated position.
 * @param x
 * @param y
 */
function setCursor(x, y) {
    cursor.x = x || 0;
    cursor.y = y || 0;
}


function textWidth(text) {
    if (!textExport.loaded) {
        console.log("text not loaded...");
        return;
    }
    var width = 0;
    text = text || '';
    for (var i = 0; i < text.length; i++) {
        var char = fontCache[text.charCodeAt(i)].char;
        width += char.xadvance;
    }
    return width;
}

},{"./canvas":3,"./changeColor":4,"./config":6,"./utils":21}],21:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';

function isWithin(point, rect) {
    var x = isBetween(point.x, rect.x, rect.x + rect.w);
    var y = isBetween(point.y, rect.y, rect.y + rect.h);
    return x && y;

}

function clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
}

function isBetween(value, min, max) {
    return value >= min && value < max;
}

function scaleRect(rect, scale) {
    //return {
    //    x: (rect.x * scale),
    //    y: (rect.y * scale),
    //    w: Math.floor(rect.w * scale),
    //    h: (rect.h * scale)
    //};
    return rect;
}


function distance(p1, p2) {
    return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
}


function extend() {
    var defaults = arguments[0];
    var options = arguments[1];

    var extended = {};
    if (arguments[2]) {
        extended = defaults;
    }

    var prop;
    for (prop in defaults) {
        if (Object.prototype.hasOwnProperty.call(defaults, prop)) {
            extended[prop] = defaults[prop];
        }
    }
    for (prop in options) {
        if (Object.prototype.hasOwnProperty.call(options, prop)) {
            extended[prop] = options[prop];
        }
    }
    return extended;
}


module.exports = {
    clamp: clamp,
    distance: distance,
    extend: extend,
    isBetween: isBetween,
    isWithin: isWithin,
    scaleRect: scaleRect
};
},{}]},{},[1])


//# sourceMappingURL=0.0.0.dungeoncrawler.min.js.map