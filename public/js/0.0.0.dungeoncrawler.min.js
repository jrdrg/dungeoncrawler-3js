(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

require('./text');  // load text etc

var lastTime;

window.onload = function () {

    var w = window;
    var requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;

    var config = require('./config');
    var input = require('./input');
    var gameLoop = require('./gameLoop');
    var canvas = require('./canvas');
    var renderer = require('./renderer');


    function main() {
        var now = Date.now();
        var delta = now - lastTime;

        gameLoop.update(delta / 1000);
        gameLoop.render();

        lastTime = now;

        // Request to do this again ASAP
        requestAnimationFrame(main);
    }

    renderer.initialize();
    document.body.appendChild(renderer.getElement());

    if (window.addEventListener) {
        //window.addEventListener('resize', canvas.resizeCanvas, false);
        window.addEventListener('orientationchange', canvas.resizeCanvas, false);
    }
    input.registerEventHandlers();

    lastTime = Date.now();

    //canvas.resizeCanvas();
    main();
};
},{"./canvas":3,"./config":5,"./gameLoop":6,"./input":11,"./renderer":16,"./text":26}],2:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

var activeMap = module.exports = {};


var atlas = require('./map/atlas'),
    player = require('./player');


activeMap.canMove = function canMove(dx, dy) {
    var map = activeMap.getCurrentMap();

    var xc = player.position.x + dx;
    var yc = player.position.y + dy;

    return map.data[yc][xc] === 0;
};


activeMap.getCurrentMap = function getCurrentMap() {
    return atlas.maps[player.currentMap];
};
},{"./map/atlas":12,"./player":15}],3:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 *
 * This module gives access to the HUD canvas for drawing status, character info, etc on top of the WebGL
 * Three.js renderer.
 *
 * Because Three.js will map this onto a plane geometry the size of the screen, there's no need for double
 * buffering to rescale the pixel art, etc.
 */

'use strict';


var config = require('./config');


//var bgCanvas = createNewCanvas(config.width, config.height);
//var bgCtx = bgCanvas.getContext("2d");

var canvas = createNewCanvas(config.width, config.height);
var ctx = canvas.getContext("2d");


module.exports = {
    clear: clear,
    //context: bgCtx,
    context: ctx,
    createNewCanvas: createNewCanvas,
    draw: draw,
    element: canvas,
    redraw: true,
    resizeCanvas: resizeCanvas
};

///////////////////////////////

function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    //bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
}


function createNewCanvas(width, height) {
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    return canvas;
}


function draw() {
    var w = config.width;// * config.scale;
    var h = config.height;// * config.scale;
    //ctx.drawImage(bgCanvas, 0, 0, w, h);
    ctx.drawImage(canvas, 0, 0, w, h);
}


// shamelessly ripped from heroine dusk code
function resizeCanvas() {
    var aspect_ratio = 4 / 3;

    var h, w;

    // the screen is wider than 4:3
    if (window.innerWidth * (3 / 4) > window.innerHeight) {
        h = window.innerHeight;
        w = h * aspect_ratio;
        config.scale = h / config.height;
    }
    // the screen is taller than 4:3
    else {
        w = window.innerWidth;
        h = w / aspect_ratio;
        config.scale = w / config.width;
    }

    config.scale = Math.floor(config.scale);
    //canvas.height = h;
    //canvas.width = w;
    canvas.height = config.height * config.scale;
    canvas.width = config.width * config.scale;

    module.exports.redraw = true;
    setNearestNeighbor();
}


function setNearestNeighbor() {
    ctx.imageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
    ctx.oImageSmoothingEnabled = false;
}

},{"./config":5}],4:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var canvas = require('./canvas');


/**
 * @description         Examines each pixel in the given image and changes all oldColor pixels to newColor, or if oldColor
 *                      is not specified then changes all non-black pixels to newColor
 * @param img
 * @param newColor      {Object} - {r, g, b}
 * @param oldColor      {Object} - {r, g, b}
 * @returns {String}    A DataURL that can be used as a .src for an Image
 */
function changeColor(img, newColor, oldColor) {
    newColor = newColor || {};
    oldColor = oldColor || {};

    var cnv = canvas.createNewCanvas(img.width, img.height);
    var ctx = cnv.getContext('2d');

    var nR = newColor.r || 0,
        nG = newColor.g || 0,
        nB = newColor.b || 0;

    var oR = oldColor.r,
        oG = oldColor.g,
        oB = oldColor.b;

    ctx.drawImage(img, 0, 0);

    // pull the entire image into an array of pixel data
    var imageData = ctx.getImageData(0, 0, img.width, img.height);

    // examine every pixel,
    // change any old rgb to the new-rgb
    for (var i = 0; i < imageData.data.length; i += 4) {
        if ((imageData.data[i] == oR &&
            imageData.data[i + 1] == oG &&
            imageData.data[i + 2] == oB
            ) || ((!oR && !oG && !oB) && imageData.data[i] > 0)) {

            imageData.data[i] = nR;
            imageData.data[i + 1] = nG;
            imageData.data[i + 2] = nB;
        }
    }
    // put the altered data back on the canvas
    ctx.putImageData(imageData, 0, 0);
    return cnv.toDataURL();
}

module.exports = changeColor;
},{"./canvas":3}],5:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';

var scaleFactor = 2;

var config = {
    fps: 60,
    scale: 1,
    width: 160 * scaleFactor,
    height: 120 * scaleFactor
};

module.exports = config;

},{}],6:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';

var gameState = require('./gameState');
var canvas = require('./canvas');
var renderer = require('./renderer');

var screens = {
    loading: require('./screens/loading'),
    //title: require('./screens/title'),
    //town: require('./screens/town'),
    dungeon: require('./screens/dungeon')
};

var states = gameState.states;


module.exports = {
    update: update,
    render: render
};

////////////////////////////////

function update(delta) {
    renderer.update(delta);

    switch (gameState.currentState) {

        case states.LOADING:
            screens.loading.update(delta);
            break;

        //case states.TITLE:
        //    screens.title.update(delta);
        //    break;
        //
        //case states.TOWN:
        //    screens.town.update(delta);
        //    break;

        case states.DUNGEON:
            screens.dungeon.update(delta);
            break;
    }
}


function render() {
    renderer.render();


    /*  only draw other stuff if we've updated the canvas */
    if (!canvas.redraw) return;
    canvas.clear();

    switch (gameState.currentState) {

        case states.LOADING:
            screens.loading.render();
            break;

        //case states.TITLE:
        //    screens.title.render();
        //    break;
        //
        //case states.TOWN:
        //    screens.town.render();
        //    break;

        case states.DUNGEON:
            screens.dungeon.render();
            break;

    }
    canvas.draw();
    canvas.redraw = false;
}
},{"./canvas":3,"./gameState":7,"./renderer":16,"./screens/dungeon":21,"./screens/loading":24}],7:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */



'use strict';

var canvas = require('./canvas');
var ctx = canvas.context;

var states = {
    LOADING: "loading",
    TITLE: "title",
    TOWN: "town",
    DUNGEON: "dungeon",
    BATTLE: "battle"
};


var gameState = {
    currentState: states.LOADING,
    setNextState: setNextState,
    states: states
};


module.exports = gameState;

//////////////////////////


function setNextState(state) {
    ctx.globalAlpha = 1;
    canvas.redraw = true;
    gameState.currentState = state;
}
},{"./canvas":3}],8:[function(require,module,exports){
/**
 * Created by john on 3/24/15.
 */

'use strict';


module.exports = {
    update: update,
    render: render
};


//var party = require('./characters/party');
var text = require('./../text');
var input = require('./../input');


var party = [
    {name: 'Char 1', className: 'Fighter', level: 1, hp: 10, maxHp: 10},
    {name: 'Char 2', className: 'Thief', level: 1, hp: 8, maxHp: 8},
    {name: 'Char 3', className: 'Priest', level: 1, hp: 8, maxHp: 8},
    {name: 'Char 4', className: 'Wizard', level: 1, hp: 4, maxHp: 4}
];


var widths = {
    name: 80,
    class: 70,
    level: 35,
    hp: 60
};


function update(delta) {
    // no update yet
}


function render(rect) {
    var margin = 0;

    var x = rect.x + margin;
    var y = rect.y + margin;

    text.drawText('Name', x, y, 'green');
    x += widths.name;

    text.drawText('HP', x, y, 'green');
    x += widths.hp;

    text.drawText('Class', x, y, 'green');
    x += widths.class;

    text.drawText('Level', x, y, 'green');
    x += widths.level;

    y += 12;
    for (var i = 0; i < party.length; i++) {
        drawCharacter(party[i], rect.x + margin, y + (i * 10));
    }
}


function drawCharacter(character, x, y) {
    var ox = x;
    var oy = y;

    text.drawText(character.name, x, y);
    x += widths.name;

    text.drawText(character.hp + '/' + character.maxHp, x, y);
    x += widths.hp;

    text.drawText(character.className, x, y);
    x += widths.class;

    text.drawText(character.level + '', x, y);
    x += widths.level;

}



},{"./../input":11,"./../text":26}],9:[function(require,module,exports){
/**
 * Created by john on 3/24/15.
 */

'use strict';

var hud = module.exports = {};

var characterDisplay = require('./characterDisplay');
var canvas = require('../canvas'),
    images = require('../images'),
    input = require('../input'),
    text = require('../text');

hud.drawMore = drawMore;
hud.message = '';
hud.render = render;
hud.setMessage = setMessage;
hud.update = update;

var messageColor = 'green';

function update(delta) {
    characterDisplay.update(delta);
}

function render() {
    if (hud.message) {
        text.drawCentered(hud.message, 10, messageColor);
    }

    characterDisplay.render({x: 30, y: 240 - 65, w: 310, h: 60});
}


function setMessage(message, color) {
    hud.message = message;
    canvas.redraw = true;

    messageColor = color || 'green';
}


function drawMore(x) {
    images.drawImage('moreArrow', x, 14);
}

},{"../canvas":3,"../images":10,"../input":11,"../text":26,"./characterDisplay":8}],10:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var imageExports = module.exports = {};


var canvas = require('./canvas');
var ctx = canvas.context;

var totalImages = 9999;
var loadedImages = 0;
var loaded = false;

var images = {};


images.wallTexture = loadImage('walltexture');
images.floorTexture = loadImage('floortexture');

//images.title = loadImage('title');

images.borderUL = loadImage('textborder', {x: 0, y: 0, w: 16, h: 16});
images.borderU = loadImage('textborder', {x: 16, y: 0, w: 16, h: 16});
images.borderUR = loadImage('textborder', {x: 32, y: 0, w: 16, h: 16});
images.borderL = loadImage('textborder', {x: 0, y: 16, w: 16, h: 16});
images.borderM = loadImage('textborder', {x: 16, y: 16, w: 16, h: 16});
images.borderR = loadImage('textborder', {x: 32, y: 16, w: 16, h: 16});
images.borderBL = loadImage('textborder', {x: 0, y: 32, w: 16, h: 16});
images.borderB = loadImage('textborder', {x: 16, y: 32, w: 16, h: 16});
images.borderBR = loadImage('textborder', {x: 32, y: 32, w: 16, h: 16});

//images.room = loadImage('mapTiles', {x: 16, y: 0, w: 16, h: 16});
//images.visitedroom = loadImage('mapTiles', {x: 0, y: 0, w: 16, h: 16});
//images.currentPos = loadImage('mapTiles', {x: 22, y: 22, w: 4, h: 4});
//images.hCorridor = loadImage('mapTiles', {x: 32, y: 6, w: 4, h: 4});    // real width=16
//images.vCorridor = loadImage('mapTiles', {x: 6, y: 16, w: 4, h: 4});    // real height=16
//images.stairsUp = loadImage('mapTiles', {x: 32, y: 16, w: 16, h: 16});

images.selectionArrow = loadImage('selectionarrow', {x: 0, y: 0, w: 3, h: 6});
images.moreArrow = loadImage('more_arrow', {x:1, y:0, w:5, h: 3});
images.skull = loadImage('skull', {x: 0, y: 0, w: 50, h: 50});


// get total number of images to make sure we've loaded everything
totalImages = Object.keys(images).length;
if (checkLoadComplete()) loaded = true;


imageExports.drawBorder = drawBorder;
imageExports.drawImage = drawImage;
imageExports.getBorder = getBorder;
imageExports.images = images;
imageExports.isLoaded = function isLoaded() {
    return loaded;
};
imageExports.loadPct = function loadPct() {
    return loadedImages / totalImages;
};
imageExports.withContext = withContext;

////////////////////////////////////////


function onLoad() {
    loadedImages++;
    if (checkLoadComplete()) {
        loaded = true;
    }
}

function checkLoadComplete() {
    return loadedImages >= totalImages;
}


function drawBorder(rect) {
    if (!loaded) return;
    var x = rect.x,
        y = rect.y,
        w = rect.w,
        h = rect.h;

    var borderSize = 16;

    var bottomRow = (y + h) - borderSize;
    var rightCol = (x + w) - borderSize;

    // take advantage of the fact that the border graphics are one color so we can stretch them

    drawImage('borderM', rect.x, rect.y, rect.w, rect.h);
    drawImage('borderU', rect.x, rect.y, rect.w, borderSize);
    drawImage('borderL', rect.x, rect.y, borderSize, rect.h);
    drawImage('borderR', rightCol, rect.y, borderSize, rect.h);
    drawImage('borderB', rect.x, bottomRow, rect.w, borderSize);

    drawImage('borderUL', x, y);
    drawImage('borderUR', rightCol, y);
    drawImage('borderBL', x, bottomRow);
    drawImage('borderBR', rightCol, bottomRow);
}


function drawImage(image, x, y, w, h) {
    if (!loaded) return;

    var img = typeof(image) === 'object' ? image : images[image];
    w = w || img.sw;
    h = h || img.sh;


    if (img.sx !== undefined && img.sy !== undefined) {
        ctx.drawImage(img, img.sx, img.sy, img.sw, img.sh, x, y, w, h);
    } else {
        ctx.drawImage(img, x, y);
    }
}


function getBorder(rect) {
    var config = require('./config');

    console.log('getBorder');
    console.log(rect);

    var cnv = canvas.createNewCanvas(config.width, config.height);
    var context = cnv.getContext("2d");

    // switch the context around and draw to the new canvas, then switch it back
    var r2 = {x: 0, y: 0, w: rect.w, h: rect.h};
    withContext(context, function () {
        drawBorder(r2);
    });
    //setContext(context);
    //setContext(canvas.context);
    return cnv;
}


function loadImage(image, src) {
    var img = new Image();
    img.onload = onLoad;
    img.src = '/images/' + image + '.png';
    if (src) {
        img.sx = src.x;
        img.sy = src.y;
        img.sw = src.w;
        img.sh = src.h;
    }
    return img;
}


function withContext(context, action) {
    setContext(context);
    action();
    setContext(canvas.context);
}


function setContext(context) {
    ctx = context;
}
},{"./canvas":3,"./config":5}],11:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';

module.exports = {
    //clickPos: clickPos,
    //getMouseClick: getMouseClick,
    //isClicked: isClicked,
    //isMouseOver: isMouseOver,

    keyDown: isKeyDown,
    handleKey: handleKey,

    //mousePos: mousePos,
    //mousePressed: mousePressed,

    processedKey: isKeyHandled,
    registerEventHandlers: registerEventHandlers
};


var config = require('./config'),
    element = require('./canvas').element,
    utils = require('./utils');


var KEYCODE = {
    // these are the arrow keys
    ARROW_UP: 38,
    ARROW_DOWN: 40,
    ARROW_LEFT: 37,
    ARROW_RIGHT: 39,

    // these are WASD keys
    UP: 87,
    DOWN: 83,
    LEFT: 65,
    RIGHT: 68,
    SPACE: 32,

    ESC: 27,
    ENTER: 13,
    M: 77       // 'M' for mini-map
};


var keyMappings = [
    {key: 'up', code: KEYCODE.UP},
    {key: 'down', code: KEYCODE.DOWN},
    {key: 'left', code: KEYCODE.LEFT},
    {key: 'right', code: KEYCODE.RIGHT},
    {key: 'action', code: KEYCODE.SPACE},
    {key: 'cancel', code: KEYCODE.ESC},
    {key: 'confirm', code: KEYCODE.ENTER},

    {key: 'a_up', code: KEYCODE.ARROW_UP},
    {key: 'a_down', code: KEYCODE.ARROW_DOWN},
    {key: 'a_left', code: KEYCODE.ARROW_LEFT},
    {key: 'a_right', code: KEYCODE.ARROW_RIGHT},

    {key: 'map', code: KEYCODE.M}
];

var mousePressed = {
    left: false,
    right: false
};

var preventInput = {
    left: false,
    right: false
};

var keyDown = {
    left: false,
    right: false,
    up: false,
    down: false
};

var processedKey = {
    left: false,
    right: false,
    up: false,
    down: false,
    action: false
};


var mousePos = {x: 0, y: 0};
var clickPos = null;


function handleMouseDown(evt) {
    evt.preventDefault();
    mousePressed.left = true;
    clickPos = clickCoord(evt);
}

function handleMouseUp(evt) {
    mousePressed.left = false;
    preventInput.left = false;
    clickPos = null;
}

function handleMouseOver(evt) {
    mousePos = clickCoord(evt);
}

function clickCoord(evt) {

    var canx;
    var cany;

    if (evt.pageX || evt.pageY) {
        canx = evt.pageX;
        cany = evt.pageY;
    }
    else {
        canx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        cany = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    canx -= element.offsetLeft;
    cany -= element.offsetTop;

    canx /= config.scale;
    cany /= config.scale;

    return {x: canx, y: cany};
}

/** Touch Handler **/

function handleTouchStart(evt) {
    evt.preventDefault();
    mousePressed.left = true;
    mousePos = touchCoord(evt);
}


function handleTouchEnd(evt) {
    mousePressed.left = false;
    preventInput.left = false;
}


function handleKeyDown(evt) {
    var processed = false;
    keyMappings.forEach(function (mapping) {

        if (!processed && evt.keyCode === mapping.code) {
            keyDown[mapping.key] = true;
            evt.preventDefault();

            processed = true;
        }
    });
}


function handleKeyUp(evt) {
    var processed = false;
    keyMappings.forEach(function (mapping) {

        if (!processed && evt.keyCode === mapping.code) {
            keyDown[mapping.key] = false;
            processedKey[mapping.key] = false;

            processed = true;
        }
    });
}


function registerEventHandlers() {
    if (window.addEventListener) {
        window.addEventListener('keydown', handleKeyDown, true);
        window.addEventListener('keyup', handleKeyUp, true);
        window.addEventListener('mousedown', handleMouseDown, true);
        window.addEventListener('mouseup', handleMouseUp, true);
        window.addEventListener('mousemove', handleMouseOver, true);
        window.addEventListener('touchstart', handleTouchStart, true);
        window.addEventListener('touchend', handleTouchEnd, true);
    }
}


/**
 * Returns true if the mouse is down within the specified rectangle
 * @param rect
 */
function isClicked(rect) {
    if (!rect) return false;
    if (preventInput.left) {
        console.log("preventinput");
        return false;
    }

    var clicked = mousePressed.left && isMouseOver(rect);
    if (clicked) {
        // make sure we don't process 2 clicks in 2 subsequent frames if the button is held down
        mousePressed.left = false;
    }
    return clicked;
}


function getMouseClick() {
    if (preventInput.left) return false;

    var clicked = mousePressed.left;
    if (clicked) {
        mousePressed.left = false;
        return clickPos;
    }
    return null;
}


function touchCoord(evt) {
    var canx = evt.touches[0].pageX;
    var cany = evt.touches[0].pageY;

    canx -= element.offsetLeft;
    cany -= element.offsetTop;

    canx /= config.scale;
    cany /= config.scale;

    return {x: canx, y: cany};
}

function handleKey(key, processed) {
    processedKey[key] = processed;
}

function isMouseOver(rect) {
    if (!rect) return false;
    return utils.isWithin(mousePos, rect);
}

function isKeyDown(key, processed) {
    return keyDown[key] && (!processed || !isKeyHandled(key));
}

function isKeyHandled(key) {
    return processedKey[key];
}


},{"./canvas":3,"./config":5,"./utils":28}],12:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

var atlas = module.exports = {};


var map2 = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1],
    [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1],
    [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
];


var maps = [
    {
        name: 'Starting map',
        data: map2,
        encounterIncrement: 0.05,
        //rooms: initialize(map),
        ////startRoom: {x: 2, y: 2},
        startRoom: {x: 0, y: 3},
        maxEncounterChance: 0.6
    }
];


atlas.maps = maps;

},{}],13:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

module.exports = {
    getMapGeometry: getMapGeometry
};

var textures = require('../textures');

/**
 * Returns two meshes for the map itself and the floor
 * @param map
 * @returns {{mesh: *, floor: *}}
 */
function getMapGeometry(map) {
    return {
        mesh: getMapMesh(map),
        floor: getFloor(map),
        ceiling: getCeiling(map)
    };
}


/**
 * Translate all points in a geometry `n` units in the x direction.
 */
function transX(geo, n) {
    for (var i = 0; i < geo.vertices.length; i++) {
        geo.vertices[i].x += n;
    }
}

/**
 * Translate all points in a geometry `n` units in the z direction.
 */
function transZ(geo, n) {
    for (var i = 0; i < geo.vertices.length; i++) {
        geo.vertices[i].z += n;
    }
}


/**
 * Returns a mesh representing the floor of the current level.
 * @param map
 * @returns {THREE.Mesh}
 */
function getFloor(map) {

    var width = map[0].length;
    var height = map.length;
    var cellSize = 200;

    var texture = textures.getTexture('floor');
    texture.minFilter = THREE.NearestFilter;
    texture.magFilter = THREE.NearestFilter;

    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    texture.repeat.set(width * 1, height * 1);
    texture.needsUpdate = true;

    var material = new THREE.MeshPhongMaterial({map: texture, doubleSided: true, side: THREE.DoubleSide});
    var geometryPlane = new THREE.PlaneBufferGeometry(width * 1 * cellSize, height * 1 * cellSize);
    var plane = new THREE.Mesh(geometryPlane, material);

    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -100;    // center is at 0, height is 200
    plane.position.x = (width / 2) * cellSize;
    plane.position.z = (height / 2) * cellSize;

    return plane;
}


function getCeiling(map) {
    var width = map[0].length;
    var height = map.length;
    var cellSize = 200;

    var texture = textures.getTexture('floor');
    texture.minFilter = THREE.NearestFilter;
    texture.magFilter = THREE.NearestFilter;

    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    texture.repeat.set(width * 1, height * 1);
    texture.needsUpdate = true;

    var material = new THREE.MeshPhongMaterial({map: texture, doubleSided: true, side: THREE.DoubleSide});
    var geometryPlane = new THREE.PlaneBufferGeometry(width * 1 * cellSize, height * 1 * cellSize);
    var plane = new THREE.Mesh(geometryPlane, material);

    plane.rotation.x = -Math.PI / 2;
    plane.position.y = 100;    // center is at 0, height is 200
    plane.position.x = (width / 2) * cellSize;
    plane.position.z = (height / 2) * cellSize;

    return plane;
}


/**
 * Returns a mesh representing the maze geometry of the current level.
 * @param map
 * @returns {THREE.Mesh}
 */
function getMapMesh(map) {
    var geometry, material, mesh;
    var img = textures.getTexture('wall');
    img.minFilter = THREE.NearestFilter;
    img.magFilter = THREE.NearestFilter;

    geometry = new THREE.BoxGeometry(200, 200, 200);
    material = new THREE.MeshLambertMaterial({color: 0xaabbaa, wireframe: false, map: img});

    var height = map.length;
    var width = map[0].length;

    for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++) {

            if (map[j][i] === 1) {
                var tmp = new THREE.BoxGeometry(200, 200, 200);
                transX(tmp, i * 200);
                transZ(tmp, j * 200);

                geometry.merge(tmp);
            }

        }
    }

    mesh = new THREE.Mesh(geometry, material);
    return mesh;
}



},{"../textures":27}],14:[function(require,module,exports){
/**
 * Created by john on 3/26/15.
 */

'use strict';

module.exports = Menu;

var
    images = require('../images'),
    input = require('../input'),
    player = require('../player'),
    sounds = require('../sounds'),
    text = require('../text'),
    utils = require('../utils')
    ;


function Menu(sizeRect, options) {
    this.border = images.getBorder(sizeRect);
    this.options = [];
    this.parentMenu = options.parent || null;   // when cancel is pressed, what menu to go back to
    this.selectedIndex = 0;
    this.size = sizeRect;
    this.subMenu = null;    // display a sub menu

    var xPos = 5,
        yPos = 0,
        self = this;

    options.forEach(function (o) {
        var opt = utils.extend(o, {
            menu: self,
            x: xPos + 2,
            y: yPos += 10
        });
        self.options.push(opt);
    });
}


Menu.prototype.render = function () {
    var self = this;
    images.drawImage(this.border, this.size.x, this.size.y);

    for (var i = 0; i < this.options.length; i++) {
        var o = this.options[i],
            xPos = o.x + self.size.x,
            yPos = o.y + self.size.y;

        if (this.selectedIndex === i) {
            images.drawImage('selectionArrow', xPos, yPos);
            xPos += 5;
        }
        text.drawText(o.title, xPos, yPos);
    }
};


Menu.prototype.update = function (delta) {
    // process keys etc
    if (player.getState() !== player.states.INPUT) {
        return false;
    }

    if (input.keyDown('a_up', true)) {
        input.handleKey('a_up', true);
        this.selectedIndex--;
        sounds.playSound('MENU_MOVE');

    } else if (input.keyDown('a_down', true)) {
        input.handleKey('a_down', true);
        this.selectedIndex++;
        sounds.playSound('MENU_MOVE');

    } else if (input.keyDown('confirm', true)) {
        input.handleKey('confirm', true);

        var item = this.options[this.selectedIndex];
        if (item && item.action) {
            //sounds.playSound('MENU_SELECT');
            item.action();
        }

    } else if (input.keyDown('cancel', true)) {
        input.handleKey('cancel', true);

        if (this.parentMenu) {
            // go back to parent menu
        }
    }


    if (this.selectedIndex < 0) {
        this.selectedIndex = this.options.length - 1;
    }
    this.selectedIndex = this.selectedIndex % this.options.length;
};

},{"../images":10,"../input":11,"../player":15,"../sounds":25,"../text":26,"../utils":28}],15:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var player = module.exports = {
    currentMap: 0,
    direction: 0,
    flags: []
};


var states = {
        MOVING: 0,
        TURNING: 1,
        INPUT: 2,
        NO_MOVE: 3
    },
    currentState = states.INPUT;


player.direction = Math.PI;
player.hasFlag = hasFlag;
player.position = {x: 3, y: 3};
player.setFlag = setFlag;
player.states = states;


player.getState = function getState() {
    return currentState;
};

player.setState = function setState(state) {
    currentState = state;
};


function hasFlag(flag) {
    return player.flags.indexOf(flag) >= 0;
}


function setFlag(flag) {
    player.flags.push(flag);
}
},{}],16:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 *
 * This module renders the view using Three.js
 */

'use strict';

var viewRenderer = module.exports = {
    getDimensions: function () {
        return {
            width: wWidth,
            height: wHeight,
            aspect: aspect
        };
    },
    getElement: function () {
        return domElement;
    },
    initialize: initialize,
    initializeMap: initializeMap,
    render: render,
    screenShake: screenShake,
    update: update,

    getNewObject: createNewPlane
};


viewRenderer.updateHud = function updateHud() {
    cnvText.needsUpdate = true;
};

var constants = {
    CAMERA_HEIGHT: -40,
    FLOOR_HEIGHT: -100,
    MAP_HEIGHT: 0
};

var atlas = require('./map/atlas'),
    canvas = require('./canvas'),
    config = require('./config'),
    mapGeometry = require('./map/mapGeometry'),
    player = require('./player'),
    utils = require('./utils');


var cnvText;

var shake = {
    duration: 0,
    magnitude: 0
};

var scale, wWidth, wHeight, aspect;

var scene, hudScene,
    camera, hudCam,
    hudMesh,
    renderer,
    domElement,
    playerLight;

var mesh, floor, ceiling;

var tileSize = 200,
    WIDTH = config.width,
    HEIGHT = config.height;


function initialize() {

    scale = Math.floor(window.innerHeight / HEIGHT);    // scale to the available vertical space
    wWidth = WIDTH * scale;
    wHeight = HEIGHT * scale;
    aspect = wWidth / wHeight;

    cnvText = new THREE.Texture(canvas.element);
    cnvText.needsUpdate = true;
    cnvText.minFilter = THREE.NearestFilter;
    cnvText.magFilter = THREE.NearestFilter;


    scene = new THREE.Scene();
    hudScene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(70, aspect, 1, 10000);
    camera.position.y = constants.CAMERA_HEIGHT;

    var width = wWidth;
    var height = wHeight;

    hudCam = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 10000);
    hudCam.position.z = 100;

    var planeGeom = new THREE.PlaneBufferGeometry(wWidth, wHeight);
    var textMater = new THREE.MeshBasicMaterial({
        map: cnvText,
        color: 0xffffff,
        transparent: true
    });


    hudMesh = new THREE.Mesh(planeGeom, textMater);
    hudMesh.lookAt(hudCam.position); // Rotate the mesh so the face is fully visible by the camera
    hudScene.add(hudMesh);

    renderer = new THREE.WebGLRenderer({antialiasing: false});


    renderer.setSize(wWidth, wHeight);
    renderer.setClearColor(0x0088FF, 1);
    renderer.autoClear = false;

    domElement = renderer.domElement;


    playerLight = new THREE.PointLight(0xaaaaaa);
    playerLight.castShadow = true;
    playerLight.shadowMapWidth = 128;
    playerLight.shadowMapHeight = 128;
    playerLight.shadowCameraNear = 1;
    playerLight.shadowCameraFar = 100; //XXX: That should be far enough.
    playerLight.shadowCameraFov = 90;
    playerLight.shadowDarkness = 0.75; //XXX: Can change later...
    playerLight.intensity = 2.5;
    playerLight.angle = Math.PI / 2;
    playerLight.distance = 200 * 8;

    scene.add(camera);

    // add the light to the camera, so it always points in the same direction
    camera.add(playerLight);

}


function initializeMap() {
    clearScene();

    var geometry = mapGeometry.getMapGeometry(atlas.maps[0].data);

    mesh = geometry.mesh;
    floor = geometry.floor;
    ceiling = geometry.ceiling;

    scene.add(mesh);
    scene.add(floor);
    scene.add(ceiling);

    mesh.position.y = 0;

    renderer.render(scene, camera);
    renderer.render(hudScene, hudCam);

}


function update(delta) {
    camera.rotation.y = player.direction;

    camera.position.y = constants.CAMERA_HEIGHT;
    camera.position.z = tileSize * player.position.y;   // z-coord: fwd/back
    camera.position.x = tileSize * player.position.x;   // x-coord: left/right

    if (mesh) {
        mesh.position.y = constants.MAP_HEIGHT;
    }

    // screen shake
    if (shake.duration > 0) {

        camera.position.y += (Math.random() * shake.magnitude) - (shake.magnitude / 2);
        camera.position.x += (Math.random() * shake.magnitude) - (shake.magnitude / 2);
        camera.position.z += (Math.random() * shake.magnitude) - (shake.magnitude / 2);

        //if (mesh && floor) {
        //    var yAmt = (Math.random() * shake.magnitude) - (shake.magnitude / 2);
        //    mesh.position.y += yAmt;
        //    floor.position.y += yAmt;
        //    //camera.position.x += (Math.random() * shake.magnitude) - (shake.magnitude / 2);
        //    //camera.position.z += (Math.random() * shake.magnitude) - (shake.magnitude / 2);
        //}

        shake.duration--;
    }
}


function render() {

    renderer.render(scene, camera);
    renderer.render(hudScene, hudCam);
}


function clearScene() {
    // remove everything but the camera/light, since it was added as the first child
    for (var i = scene.children.length - 1; i > 0; i--) {
        scene.remove(scene.children[i]);
    }
}


function screenShake(duration, magnitude) {
    shake.magnitude = magnitude || 10;
    shake.duration = duration;
}


function createNewPlane() {
    function PlaneObject() {
        var width = config.width;
        var height = config.height;
        var cellSize = 200;

        var cnv = document.createElement('canvas');
        cnv.width = width;
        cnv.height = height;

        this.context = cnv.getContext("2d");
        this.dispose = function () {
            scene.remove(plane);
            plane.geometry.dispose();
            plane.material.dispose();
        };
        this.needsUpdate = function () {
            cText.needsUpdate = true;
        };


        var cText = new THREE.Texture(cnv);
        cText.needsUpdate = true;
        cText.minFilter = THREE.NearestFilter;
        cText.magFilter = THREE.NearestFilter;


        var texture = require('./textures').getTexture('floor');
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;

        texture.needsUpdate = true;

        //var material = new THREE.MeshLambertMaterial({map: texture, doubleSided: true, side: THREE.DoubleSide});
        var material = new THREE.MeshBasicMaterial({
            map: cText, doubleSided: true, side: THREE.DoubleSide, color: 0xffffff,
            transparent: true
        });
        var geometryPlane = new THREE.PlaneBufferGeometry(width, height);
        var plane = new THREE.Mesh(geometryPlane, material);

        // makes it face the same direction as the player
        var vect = require('./utils').directionToVector(player.direction);

        plane.rotation.y = player.direction;
        plane.position.y = 0;    // center is at 0, height is 200
        plane.position.x = (player.position.x * cellSize) + (-vect.x * cellSize / 2);
        plane.position.z = (player.position.y * cellSize) + (-vect.y * cellSize / 2);

        scene.add(plane);

    }

    return new PlaneObject();
}
},{"./canvas":3,"./config":5,"./map/atlas":12,"./map/mapGeometry":13,"./player":15,"./textures":27,"./utils":28}],17:[function(require,module,exports){
/**
 * Created by john on 3/28/15.
 */

'use strict';

module.exports = Battle;


var activeMap = require('../../activeMap'),
    config = require('../../config'),
    Enemy = require('./Enemy'),
    hud = require('../../hud'),
    input = require('../../input'),
    Menu = require('../../menu'),
    sounds = require('../../sounds'),
    utils = require('../../utils');

var rowPositionsX = [
    [
        [130],
        [100, 160],
        [70, 140, 210],
        [60, 110, 160, 210]
    ],
    [
        [135],
        [95, 155],
        [75, 145, 215],
        [65, 115, 165, 215]
    ]
];

var rowPositionsY = [80, 70, 65];
var plane;

var states = {
    FIGHT: 0,
    ESCAPED: 1
};

var endBattleCounter = 0;


/**
 * Represents the current battle. A new one gets created and assigned to currentBattle each time combat.init() is called
 * @constructor
 */
function Battle(combat) {
    var self = this;
    var map = activeMap.getCurrentMap();
    //plane = renderer.getNewObject();

    this.combat = combat;
    this.enemies = initializeEnemies();
    this.menu = new Menu({
        x: 150,
        y: config.height - 70,
        w: config.width - 180,
        h: 60
    }, [
        {title: 'Fight'},
        {
            title: 'Run',
            action: function () {
                self.run();
            }
        },
        {title: '9/9/9/9/9/9/9/9/9'},
        {title: 'Skill'}
    ]);
    this.state = states.FIGHT;


    function initializeEnemies() {
        var enemies = [];
        var numRows = utils.randomBetween(1, 2);
        for (var r = 0; r < numRows; r++) {
            var numEnemies = utils.randomBetween(1, 4);
            var row = [];
            var xPos = rowPositionsX[r][numEnemies - 1];

            for (var e = 0; e < numEnemies; e++) {
                var x = xPos[e];
                var y = rowPositionsY[r];

                var enemy = new Enemy({image: 'skull'}, x, y);
                row.push(enemy);
            }
            enemies.push(row);
        }
        return enemies;
    }
}

Battle.prototype.update = function (delta) {
    switch (this.state) {
        case states.FIGHT:
            for (var i = this.enemies.length - 1; i >= 0; i--) {
                for (var j = 0; j < this.enemies[i].length; j++) {
                    var enemy = this.enemies[i][j];
                    if (enemy.isAlive) {
                        enemy.update(delta);
                    }
                }
            }
            this.menu.update(delta);
            break;

        case states.ESCAPED:
            //var ctx = require('../../canvas').context;
            //if (endBattleCounter < 99) {
            //    endBattleCounter++;
            //}
            //if (endBattleCounter > 0) {
            //    ctx.globalAlpha = 1 / (endBattleCounter + 1);
            //}
            if (input.keyDown('confirm', true) || input.keyDown('action', true) || input.keyDown('cancel', true)) {
                //ctx.globalAlpha = 1;
                this.combat.endBattle();
            }
            break;
    }

};

Battle.prototype.render = function () {
    //var img = images.images.skull;
    //var ctx = plane.context;
    //ctx.drawImage(img, 60, 50);
    //plane.needsUpdate();

    switch (this.state) {
        case states.FIGHT:
            for (var i = this.enemies.length - 1; i >= 0; i--) {
                for (var j = 0; j < this.enemies[i].length; j++) {
                    var enemy = this.enemies[i][j];
                    if (enemy.isAlive) {
                        enemy.draw(i);
                    }
                }
            }
            this.menu.render();
            break;

        case states.ESCAPED:

            break;
    }

};


Battle.prototype.dispose = function () {
    //plane.dispose();
};


Battle.prototype.run = function () {
    // check if we can run
    if (Math.random() <= 0.5) {
        hud.setMessage("You managed to escape.");
        hud.drawMore(200);
        sounds.playSound('RUN');
        this.state = states.ESCAPED;

    } else {
        hud.setMessage("Can't run!", 'red');
        sounds.playSound('NO_RUN');
    }
};
},{"../../activeMap":2,"../../config":5,"../../hud":9,"../../input":11,"../../menu":14,"../../sounds":25,"../../utils":28,"./Enemy":18}],18:[function(require,module,exports){
/**
 * Created by john on 3/26/15.
 */

'use strict';

module.exports = Enemy;


var canvas = require('../../canvas'),
    images = require('../../images'),
    utils = require('../../utils');

var context = canvas.context;


function Enemy(definition, x, y) {
    definition = definition || {};

    this.image = definition.image || 'skull';
    this.isAlive = true;
    this.level = 1;
    this.name = definition.name || 'Skull';
    this.position = {x: x, y: y};

    this.onUpdate = definition.onUpdate || getDefaultOnUpdate(this);
}


Enemy.prototype.update = function (delta) {

    this.onUpdate(delta);
};


Enemy.prototype.draw = function (row) {
    context.globalAlpha = 1 / ((row + 1));
    images.drawImage(this.image, Math.round(this.position.x), Math.round(this.position.y));
    context.globalAlpha = 1;
};


/**
 * Default update behavior, just moves the sprite up and down between a min and max y-value
 * @param enemy
 * @returns {Function}
 */
function getDefaultOnUpdate(enemy) {
    var yBounds = {
        min: enemy.position.y - Math.ceil(Math.random() * 3) + 2,
        max: enemy.position.y + Math.ceil(Math.random() * 3) + 2
    };
    var dir = Math.round(Math.random() * 2) - 1;
    if (dir === 0) dir = -1;

    return function defaultOnUpdate(delta) {
        var amount = utils.clamp(delta * 10, 0, 1);
        if (dir === 1) {
            if (enemy.position.y < yBounds.max) {
                enemy.position.y += amount;
            } else {
                dir = -1;
            }

        } else if (dir === -1) {
            if (enemy.position.y > yBounds.min) {
                enemy.position.y -= amount;
            } else {
                dir = 1;
            }
        }
    };
}
},{"../../canvas":3,"../../images":10,"../../utils":28}],19:[function(require,module,exports){
/**
 * Created by john on 3/25/15.
 */


'use strict';


var combat = module.exports = {
    nextState: 'BATTLE',
    update: update,
    render: render,
    endBattle: endBattle
};

combat.init = function initialize() {
    console.log("New battle!");
    sounds.playSound('START_BATTLE');
    currentBattle = new Battle(combat);

    combat.nextState = 'BATTLE';
};

combat.getBattle = function getBattle() {
    return currentBattle;
};


var
    Battle = require('./Battle'),
    canvas = require('../../canvas'),
    config = require('../../config'),
    hud = require('../../hud'),
    images = require('../../images'),
    input = require('../../input'),
    player = require('../../player'),
    renderer = require('../../renderer'),
    sounds = require('../../sounds'),
    utils = require('../../utils')
    ;

var dims = {
    width: config.width,
    height: config.height
};


var currentBattle = null;


function update(delta) {
    processKeys();

    if (currentBattle) {
        currentBattle.update(delta);
        canvas.redraw = true;
    }
    hud.update(delta);
}


function render() {

    // dim the background
    var ctx = canvas.context;
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = 'rgb(30,30,40)';
    ctx.fillRect(0, 0, 320, 240);
    ctx.globalAlpha = 1;


    images.drawBorder({x: 30, y: 40, w: dims.width - 60, h: 120});

    if (currentBattle) {
        currentBattle.render();
    }
}


function processKeys() {
    if (player.getState() !== player.states.INPUT) {
        return false;
    }

    if (input.keyDown('action', true)) {
        input.handleKey('action', true);

        hud.setMessage("action key pressed");

        renderer.screenShake(20, 30);

    } else if (input.keyDown('cancel', true)) {

    }
}


function endBattle() {
    if (currentBattle) currentBattle.dispose();
    combat.nextState = 'EXPLORE';
}
},{"../../canvas":3,"../../config":5,"../../hud":9,"../../images":10,"../../input":11,"../../player":15,"../../renderer":16,"../../sounds":25,"../../utils":28,"./Battle":17}],20:[function(require,module,exports){
/**
 * Created by john on 3/25/15.
 */

'use strict';


var explore = module.exports = {};
explore.init = init;
explore.nextState = 'EXPLORE';
explore.render = render;
explore.update = update;


var activeMap = require('../../activeMap'),
    canvas = require('../../canvas'),
    hud = require('../../hud'),
    keys = require('./keys'),
    movement = require('./movement');


var keyHandlers = [
    {handler: movement, callback: onMoveComplete},
    {handler: keys}
];

var encounterChance = 0;


function init() {
    hud.setMessage('');
    explore.nextState = 'EXPLORE';
}

function update(delta) {
    var keyPressed = false,
        existingMessage = hud.message;

    // process any key pressed
    keyHandlers.forEach(function (i) {
        if (keyPressed) return;

        var processed = i.handler.processKeys();
        if (processed) {
            keyPressed = true;
        }
    });

    // clear the displayed message if a key was pressed
    if (keyPressed && existingMessage) {
        hud.message = "";
        canvas.redraw = true;
    }

    // update all key handlers
    keyHandlers.forEach(function (i) {
        i.handler.update(delta, i.callback);
    });

    hud.update(delta);
}


function render() {

}


function onMoveComplete(moved) {
    if (!moved) {
        hud.setMessage("There is a wall there!", 'red');

    } else {
        // check for random battles, events on the tile, etc
        var currentMap = activeMap.getCurrentMap();

        encounterChance += currentMap.encounterIncrement;
        encounterChance = Math.min(encounterChance, currentMap.maxEncounterChance);

        if (Math.random() < encounterChance) {
            hud.setMessage('Something approaches!');
            console.log("Battle! pct=" + encounterChance);

            // enter battle!
            encounterChance = 0;
            explore.nextState = 'BATTLE';
        }

    }

    canvas.redraw = true;
}
},{"../../activeMap":2,"../../canvas":3,"../../hud":9,"./keys":22,"./movement":23}],21:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';

var dungeon = module.exports = {};

var canvas = require('../../canvas'),
    config = require('../../config'),
    hud = require('../../hud'),
    input = require('../../input'),
    keys = require('./keys'),
    renderer = require('../../renderer'),
    text = require('../../text');


var states = {
        EXPLORE: require('./explore'),
        BATTLE: require('./combat'),
        MENU: {}
    },
    currentState = states.EXPLORE;


/**
 * @description     Updates each frame
 */
dungeon.update = function update(delta) {

    currentState.update(delta);

    var nextState = states[currentState.nextState];

    if (nextState !== currentState) {
        currentState = nextState;
        if (currentState.init) {
            currentState.init();
        }

        // always redraw on state changes
        canvas.redraw = true;
    }
};


/**
 * @description     Renders the view
 */
dungeon.render = function render() {

    hud.render();
    currentState.render();

    renderer.updateHud();
};
},{"../../canvas":3,"../../config":5,"../../hud":9,"../../input":11,"../../renderer":16,"../../text":26,"./combat":19,"./explore":20,"./keys":22}],22:[function(require,module,exports){
/**
 * Created by john on 3/25/15.
 */

'use strict';

var keys = module.exports = {};

var canvas = require('../../canvas'),
    hud = require('../../hud'),
    input = require('../../input'),
    player = require('../../player');

var renderer = require('../../renderer');

keys.processKeys = processKeys;
keys.update = function update(delta) {

};


function processKeys() {
    if (player.getState() !== player.states.INPUT) {
        return false;
    }

    if (isKeyDown('action')) {
        input.handleKey('action', true);

        hud.setMessage("action key pressed");

        renderer.screenShake(20, 30);
    }
}


function isKeyDown(key) {
    return input.keyDown(key) && !input.processedKey(key);
}
},{"../../canvas":3,"../../hud":9,"../../input":11,"../../player":15,"../../renderer":16}],23:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var movement = module.exports = {};

var activeMap = require('../../activeMap'),
    input = require('../../input'),
    player = require('../../player'),
    sounds = require('../../sounds'),
    util = require('../../utils');


var keys = {left: false, right: false, up: false, down: false};

var turnTo = {
        from: 0,
        to: 0,
        dir: 0
    },
    walkTo = {
        from: 0,
        to: 0,
        dir: 0
    };


movement.processKeys = processKeys;
movement.update = update;


function processKeys() {

    keys = {
        left: false, right: false, up: false, down: false
    };
    if (player.getState() === player.states.INPUT) {
        var keyPressed = false;
        for (var key in keys) {
            if (keys.hasOwnProperty(key)) {

                if (input.keyDown(key)) {

                    if (!input.processedKey(key)) {
                        input.handleKey(key, true);

                        keys[key] = true;
                        keyPressed = true;
                        break;
                    }
                }
            }
        }

        return keyPressed;
    }
    return false;
}

function update(delta, moveCompleteCallback) {

    var vect;
    switch (player.getState()) {

        case player.states.INPUT:

            if (keys.left) {

                player.direction -= (Math.PI * 2);
                turnTo = {
                    from: player.direction,
                    to: (player.direction + (Math.PI / 2)) % (2 * Math.PI),
                    dir: -1
                };

            } else if (keys.right) {
                player.direction += (Math.PI * 2);  // so that our calculations for delta etc still work
                turnTo = {
                    from: player.direction,
                    to: (player.direction - (Math.PI / 2)) % (2 * Math.PI),
                    dir: 1
                };

            } else if (keys.up) {

                vect = {
                    x: Math.round(Math.sin(player.direction % (2 * Math.PI))) * -1,
                    y: Math.round(Math.cos(player.direction % (2 * Math.PI))) * -1
                };

                walkTo = {
                    from: {x: player.position.x, y: player.position.y},
                    to: {x: player.position.x + vect.x, y: player.position.y + vect.y},
                    dir: vect
                };


            } else if (keys.down) {

                vect = {
                    x: Math.round(Math.sin(player.direction % (2 * Math.PI))),
                    y: Math.round(Math.cos(player.direction % (2 * Math.PI)))
                };

                walkTo = {
                    from: {x: player.position.x, y: player.position.y},
                    to: {x: player.position.x + vect.x, y: player.position.y + vect.y},
                    dir: vect
                };

            }

            if (turnTo.from !== turnTo.to) {
                sounds.playSound('MOVE');
                player.setState(player.states.TURNING);

            } else if (walkTo.from !== walkTo.to) {

                if (activeMap.canMove(walkTo.dir.x, walkTo.dir.y)) {
                    sounds.playSound('MOVE');
                    player.setState(player.states.MOVING);

                } else {

                    sounds.playSound('NO_MOVE');
                    walkTo = {from: 0, to: 0, dir: 0};

                    // we can't move here, maybe do an action
                    moveCompleteCallback(false);
                }

            }

            break;

        case player.states.TURNING:

            player.direction -= (delta * (turnTo.dir) * 3);
            player.direction = player.direction % (Math.PI * 2);

            if (reachedDestination(turnTo.from, turnTo.to, player.direction)) {

                input.handleKey('left', false);
                input.handleKey('right', false);

                player.setState(player.states.INPUT);
                player.direction = turnTo.to;
                turnTo = {from: 0, to: 0, dir: 0};
            }

            break;

        case player.states.MOVING:

            player.position.x += (delta * 2 * walkTo.dir.x);
            player.position.y += (delta * 2 * walkTo.dir.y);

            var reachedX = reachedDestination(walkTo.from.x, walkTo.to.x, player.position.x);
            var reachedY = reachedDestination(walkTo.from.y, walkTo.to.y, player.position.y);

            if (reachedX && reachedY) {

                input.handleKey('up', false);
                input.handleKey('down', false);

                player.setState(player.states.INPUT);
                player.position.x = walkTo.to.x;
                player.position.y = walkTo.to.y;
                walkTo = {from: 0, to: 0, dir: 0};

                // we moved somewhere so maybe take an action
                moveCompleteCallback(true);
            }

            break;
    }
}


function reachedDestination(from, to, current) {

    if (from < to) {

        if (current >= to) {
            return true;
        }

    } else if (from > to) {

        if (current <= to) {
            return true;
        }

    } else {
        return true;
    }

    return false;
}
},{"../../activeMap":2,"../../input":11,"../../player":15,"../../sounds":25,"../../utils":28}],24:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var text = require('../text');
var images = require('../images');
var gameState = require('../gameState');
var textures = require('../textures');
var renderer = require('../renderer');


module.exports = {
    update: update,
    render: render
};


/////////////////


function render() {
    text.drawText('Loading...' + images.loadPct(), 100, 100);
}


function update(delta) {
    if (text.loaded && images.isLoaded() && textures.loadTextures()) {
        renderer.initializeMap();
        gameState.setNextState(gameState.states.DUNGEON);
    }
}
},{"../gameState":7,"../images":10,"../renderer":16,"../text":26,"../textures":27}],25:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';

var sounds = {
    MOVE: loadSound('walking', 0.5),
    NO_MOVE: loadSound('nomove'),
    START_BATTLE: loadSound('startbattle2'),
    MENU_MOVE: loadSound('menuitem', 0.4),
    MENU_SELECT: loadSound('Pickup_Coin6'),
    RUN: loadSound('battle_run2'),
    NO_RUN: loadSound('menu_select')
};


module.exports = {
    fx: sounds,
    playSound: playSound
};


/////////////////////////////

function loaded() {

}

function loadSound(sound, volume) {
    //var snd = new Audio('/sounds/' + sound + '.wav');
    //snd.volume = volume || 1.0;
    //return snd;
    var elem = document.createElement('audio');
    elem.src = '/sounds/' + sound + '.wav';
    elem.volume = volume || 1.0;
    return elem;
}


function playSound(sound) {
    try {
        sounds[sound].currentTime = 0;
        sounds[sound].play();
    }
    catch (err) {
        // do something when sound doesn't play?
        console.log(err);
    }
}


function onLoad() {

}
},{}],26:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */

'use strict';


var textExport = {
    drawCentered: drawCentered,
    drawText: drawText,
    loaded: false,
    setCursor: setCursor,
    textWidth: textWidth
};

module.exports = textExport;


var canvas = require('./canvas'),
    changeColor = require('./changeColor'),
    config = require('./config'),
    utils = require('./utils');


var ctx = canvas.context;

var dataLoaded = false,
    imageLoaded = false,
    lineHeight = 0,
    data = null,
    fontName = 'roses',
    fontImg = new Image(),
    fontCache = {},
    fontColors = {
        'default': fontImg,
        'red': new Image(),
        'green': new Image()
    };


/**
 * The position where the text will be drawn
 * @type {{x: number, y: number}}
 */
var cursor = {x: 0, y: 0};


loadFontImage(fontImg);
loadFont();


////////////////////////////////////////////////


/**
 * Draws the glyph indicated by the code.
 * @param code
 * @returns {Number} The number of pixels to advance in the x-direction.
 * @param color
 */
function drawGlyph(code, color) {
    if (!textExport.loaded) return 0;

    color = color || 'default';

    var character = fontCache[code].char;

    var dst = utils.scaleRect({
        x: cursor.x + character.xoffset,
        y: cursor.y + character.yoffset,
        w: character.width,
        h: character.height
    }, config.scale);


    if (character.width && character.height) {
        var src = {x: character.x, y: character.y, w: character.width, h: character.height};
        ctx.drawImage(fontColors[color], src.x, src.y, src.w, src.h, dst.x, dst.y, dst.w, dst.h);
    }
    return character.xadvance; // to advance the cursor
}


/**
 * Draws a string of text at the given coordinates.
 * @param text
 * @param x
 * @param y
 * @param color
 */
function drawText(text, x, y, color) {
    x = Math.round(x);
    y = Math.round(y);
    color = color || 'default';

    setCursor(x, y);

    text = text || '';
    for (var i = 0; i < text.length; i++) {
        var code = text.charCodeAt(i);
        cursor.x += drawGlyph(code, color);
    }
}


function drawCentered(text, y, color) {
    if (!textExport.loaded) return;

    var tw = textWidth(text);
    var x = Math.floor((config.width / 2) - (tw / 2));
    drawText(text, x, y, color || 'red');
}


function loadFontImage(fontImg) {
    fontImg.src = "/fontImage/" + fontName;
    fontImg.onload = function () {

        // original font color: 240, 221, 178: #F0DDB2
        // 252 234 199

        /*  assign color changes here */
        fontColors.red.src = changeColor(fontImg, {r: 200, g: 50, b: 50});//, {r: 252, g: 234, b: 199});
        fontColors.green.src = changeColor(fontImg, {r: 50, g: 200, b: 50});//, {r: 252, g: 234, b: 199});

        imageLoaded = true;
        textExport.loaded = imageLoaded && dataLoaded;
        console.log(textExport.loaded);
    };
}


function loadFont() {
    var oReq = new XMLHttpRequest();
    oReq.onload = function () {
        data = JSON.parse(this.responseText);

        lineHeight = data.common.lineHeight;

        for (var i = 0; i < data.chars.length; i++) {
            fontCache[data.chars[i].id] = {
                char: data.chars[i],
                kerning: {}
            };
        }
        for (var j = 0; j < data.kernings.length; j++) {
            var kern = data.kernings[j];
            var char = fontCache[kern.first];
            if (char) {
                char.kerning[kern.second] = kern.amount;
            } else {
                console.log(kern.first);
            }
        }

        dataLoaded = true;
        textExport.loaded = imageLoaded && dataLoaded;
        console.log(textExport.loaded);
    };
    oReq.open("get", "/font/" + fontName, true);
    oReq.send();
}


/**
 * Moves the cursor to the indicated position.
 * @param x
 * @param y
 */
function setCursor(x, y) {
    cursor.x = x || 0;
    cursor.y = y || 0;
}


function textWidth(text) {
    if (!textExport.loaded) {
        console.log("text not loaded...");
        return;
    }
    var width = 0;
    text = text || '';
    for (var i = 0; i < text.length; i++) {
        var char = fontCache[text.charCodeAt(i)].char;
        width += char.xadvance;
    }
    return width;
}

},{"./canvas":3,"./changeColor":4,"./config":5,"./utils":28}],27:[function(require,module,exports){
/**
 * Created by john on 3/25/15.
 */

'use strict';


module.exports = {
    loadTextures: loadTextures,
    getTexture: function (key) {
        return textures[key];
    }
};


var textureCount = 0;
var textures = {
    wall: THREE.ImageUtils.loadTexture('/images/walltexture.png', {}, onLoad),
    floor: THREE.ImageUtils.loadTexture('/images/floortexture.png', {}, onLoad)
};


/**
 * Allows preloading of all textures before we start rendering anything
 * @returns {boolean} True when all textures have been loaded.
 */
function loadTextures() {
    return (textureCount === Object.keys(textures).length);
}


function onLoad() {
    textureCount++;
}
},{}],28:[function(require,module,exports){
/**
 * Created by john on 3/22/15.
 */


'use strict';


module.exports = {
    clamp: clamp,
    directionToVector: directionToVector,
    distance: distance,
    extend: extend,
    isBetween: isBetween,
    isWithin: isWithin,
    randomBetween: randomBetween,
    scaleRect: scaleRect
};


function clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
}


function directionToVector(direction) {
    var vect = {
        x: Math.round(Math.sin(direction % (2 * Math.PI))),
        y: Math.round(Math.cos(direction % (2 * Math.PI)))
    };
    return vect;
}


function distance(p1, p2) {
    return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
}


function extend() {
    var defaults = arguments[0];
    var options = arguments[1];

    var extended = {};
    if (arguments[2]) {
        extended = defaults;
    }

    var prop;
    for (prop in defaults) {
        if (Object.prototype.hasOwnProperty.call(defaults, prop)) {
            extended[prop] = defaults[prop];
        }
    }
    for (prop in options) {
        if (Object.prototype.hasOwnProperty.call(options, prop)) {
            extended[prop] = options[prop];
        }
    }
    return extended;
}


function isBetween(value, min, max) {
    return value >= min && value < max;
}


function isWithin(point, rect) {
    var x = isBetween(point.x, rect.x, rect.x + rect.w);
    var y = isBetween(point.y, rect.y, rect.y + rect.h);
    return x && y;

}


function scaleRect(rect, scale) {
    return {
        x: (rect.x * scale),
        y: (rect.y * scale),
        w: Math.floor(rect.w * scale),
        h: (rect.h * scale)
    };
}


function randomBetween(min, max) {
    return Math.round(Math.random() * (max - min)) + min;
}


},{}]},{},[1])


//# sourceMappingURL=0.0.0.dungeoncrawler.min.js.map