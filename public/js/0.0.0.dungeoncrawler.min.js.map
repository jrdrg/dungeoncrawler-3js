{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/client/main.js","src/client/activeMap.js","src/client/canvas.js","src/client/changeColor.js","src/client/config.js","src/client/gameLoop.js","src/client/gameState.js","src/client/hud/characterDisplay.js","src/client/hud/index.js","src/client/images.js","src/client/input.js","src/client/map/atlas.js","src/client/map/mapGeometry.js","src/client/menu/index.js","src/client/player.js","src/client/renderer.js","src/client/screens/dungeon/Battle.js","src/client/screens/dungeon/Enemy.js","src/client/screens/dungeon/combat.js","src/client/screens/dungeon/explore.js","src/client/screens/dungeon/index.js","src/client/screens/dungeon/keys.js","src/client/screens/dungeon/movement.js","src/client/screens/loading.js","src/client/sounds.js","src/client/text.js","src/client/textures.js","src/client/utils.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"0.0.0.dungeoncrawler.min.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nrequire('./text');  // load text etc\n\nvar lastTime;\n\nwindow.onload = function () {\n\n    var w = window;\n    var requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;\n\n    var config = require('./config');\n    var input = require('./input');\n    var gameLoop = require('./gameLoop');\n    var canvas = require('./canvas');\n    var renderer = require('./renderer');\n\n\n    function main() {\n        var now = Date.now();\n        var delta = now - lastTime;\n\n        gameLoop.update(delta / 1000);\n        gameLoop.render();\n\n        lastTime = now;\n\n        // Request to do this again ASAP\n        requestAnimationFrame(main);\n    }\n\n    renderer.initialize();\n    document.body.appendChild(renderer.getElement());\n\n    if (window.addEventListener) {\n        //window.addEventListener('resize', canvas.resizeCanvas, false);\n        window.addEventListener('orientationchange', canvas.resizeCanvas, false);\n    }\n    input.registerEventHandlers();\n\n    lastTime = Date.now();\n\n    //canvas.resizeCanvas();\n    main();\n};","/**\n * Created by john on 3/22/15.\n */\n\nvar activeMap = module.exports = {};\n\n\nvar atlas = require('./map/atlas'),\n    player = require('./player');\n\n\nactiveMap.canMove = function canMove(dx, dy) {\n    var map = activeMap.getCurrentMap();\n\n    var xc = player.position.x + dx;\n    var yc = player.position.y + dy;\n\n    return map.data[yc][xc] === 0;\n};\n\n\nactiveMap.getCurrentMap = function getCurrentMap() {\n    return atlas.maps[player.currentMap];\n};","/**\n * Created by john on 3/22/15.\n *\n * This module gives access to the HUD canvas for drawing status, character info, etc on top of the WebGL\n * Three.js renderer.\n *\n * Because Three.js will map this onto a plane geometry the size of the screen, there's no need for double\n * buffering to rescale the pixel art, etc.\n */\n\n'use strict';\n\n\nvar config = require('./config');\n\n\n//var bgCanvas = createNewCanvas(config.width, config.height);\n//var bgCtx = bgCanvas.getContext(\"2d\");\n\nvar canvas = createNewCanvas(config.width, config.height);\nvar ctx = canvas.getContext(\"2d\");\n\n\nmodule.exports = {\n    clear: clear,\n    //context: bgCtx,\n    context: ctx,\n    createNewCanvas: createNewCanvas,\n    draw: draw,\n    element: canvas,\n    redraw: true,\n    resizeCanvas: resizeCanvas\n};\n\n///////////////////////////////\n\nfunction clear() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    //bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);\n}\n\n\nfunction createNewCanvas(width, height) {\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\n\n\nfunction draw() {\n    var w = config.width;// * config.scale;\n    var h = config.height;// * config.scale;\n    //ctx.drawImage(bgCanvas, 0, 0, w, h);\n    ctx.drawImage(canvas, 0, 0, w, h);\n}\n\n\n// shamelessly ripped from heroine dusk code\nfunction resizeCanvas() {\n    var aspect_ratio = 4 / 3;\n\n    var h, w;\n\n    // the screen is wider than 4:3\n    if (window.innerWidth * (3 / 4) > window.innerHeight) {\n        h = window.innerHeight;\n        w = h * aspect_ratio;\n        config.scale = h / config.height;\n    }\n    // the screen is taller than 4:3\n    else {\n        w = window.innerWidth;\n        h = w / aspect_ratio;\n        config.scale = w / config.width;\n    }\n\n    config.scale = Math.floor(config.scale);\n    //canvas.height = h;\n    //canvas.width = w;\n    canvas.height = config.height * config.scale;\n    canvas.width = config.width * config.scale;\n\n    module.exports.redraw = true;\n    setNearestNeighbor();\n}\n\n\nfunction setNearestNeighbor() {\n    ctx.imageSmoothingEnabled = false;\n    ctx.webkitImageSmoothingEnabled = false;\n    ctx.mozImageSmoothingEnabled = false;\n    ctx.oImageSmoothingEnabled = false;\n}\n","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar canvas = require('./canvas');\n\n\n/**\n * @description         Examines each pixel in the given image and changes all oldColor pixels to newColor, or if oldColor\n *                      is not specified then changes all non-black pixels to newColor\n * @param img\n * @param newColor      {Object} - {r, g, b}\n * @param oldColor      {Object} - {r, g, b}\n * @returns {String}    A DataURL that can be used as a .src for an Image\n */\nfunction changeColor(img, newColor, oldColor) {\n    newColor = newColor || {};\n    oldColor = oldColor || {};\n\n    var cnv = canvas.createNewCanvas(img.width, img.height);\n    var ctx = cnv.getContext('2d');\n\n    var nR = newColor.r || 0,\n        nG = newColor.g || 0,\n        nB = newColor.b || 0;\n\n    var oR = oldColor.r,\n        oG = oldColor.g,\n        oB = oldColor.b;\n\n    ctx.drawImage(img, 0, 0);\n\n    // pull the entire image into an array of pixel data\n    var imageData = ctx.getImageData(0, 0, img.width, img.height);\n\n    // examine every pixel,\n    // change any old rgb to the new-rgb\n    for (var i = 0; i < imageData.data.length; i += 4) {\n        if ((imageData.data[i] == oR &&\n            imageData.data[i + 1] == oG &&\n            imageData.data[i + 2] == oB\n            ) || ((!oR && !oG && !oB) && imageData.data[i] > 0)) {\n\n            imageData.data[i] = nR;\n            imageData.data[i + 1] = nG;\n            imageData.data[i + 2] = nB;\n        }\n    }\n    // put the altered data back on the canvas\n    ctx.putImageData(imageData, 0, 0);\n    return cnv.toDataURL();\n}\n\nmodule.exports = changeColor;","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\nvar scaleFactor = 2;\n\nvar config = {\n    fps: 60,\n    scale: 1,\n    width: 160 * scaleFactor,\n    height: 120 * scaleFactor\n};\n\nmodule.exports = config;\n","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\nvar gameState = require('./gameState');\nvar canvas = require('./canvas');\nvar renderer = require('./renderer');\n\nvar screens = {\n    loading: require('./screens/loading'),\n    //title: require('./screens/title'),\n    //town: require('./screens/town'),\n    dungeon: require('./screens/dungeon')\n};\n\nvar states = gameState.states;\n\n\nmodule.exports = {\n    update: update,\n    render: render\n};\n\n////////////////////////////////\n\nfunction update(delta) {\n    renderer.update(delta);\n\n    switch (gameState.currentState) {\n\n        case states.LOADING:\n            screens.loading.update(delta);\n            break;\n\n        //case states.TITLE:\n        //    screens.title.update(delta);\n        //    break;\n        //\n        //case states.TOWN:\n        //    screens.town.update(delta);\n        //    break;\n\n        case states.DUNGEON:\n            screens.dungeon.update(delta);\n            break;\n    }\n}\n\n\nfunction render() {\n    renderer.render();\n\n\n    /*  only draw other stuff if we've updated the canvas */\n    if (!canvas.redraw) return;\n    canvas.clear();\n\n    switch (gameState.currentState) {\n\n        case states.LOADING:\n            screens.loading.render();\n            break;\n\n        //case states.TITLE:\n        //    screens.title.render();\n        //    break;\n        //\n        //case states.TOWN:\n        //    screens.town.render();\n        //    break;\n\n        case states.DUNGEON:\n            screens.dungeon.render();\n            break;\n\n    }\n    canvas.draw();\n    canvas.redraw = false;\n}","/**\n * Created by john on 3/22/15.\n */\n\n\n\n'use strict';\n\nvar canvas = require('./canvas');\nvar ctx = canvas.context;\n\nvar states = {\n    LOADING: \"loading\",\n    TITLE: \"title\",\n    TOWN: \"town\",\n    DUNGEON: \"dungeon\",\n    BATTLE: \"battle\"\n};\n\n\nvar gameState = {\n    currentState: states.LOADING,\n    setNextState: setNextState,\n    states: states\n};\n\n\nmodule.exports = gameState;\n\n//////////////////////////\n\n\nfunction setNextState(state) {\n    ctx.globalAlpha = 1;\n    canvas.redraw = true;\n    gameState.currentState = state;\n}","/**\n * Created by john on 3/24/15.\n */\n\n'use strict';\n\n\nmodule.exports = {\n    update: update,\n    render: render\n};\n\n\n//var party = require('./characters/party');\nvar text = require('./../text');\nvar input = require('./../input');\n\n\nvar party = [\n    {name: 'Char 1', className: 'Fighter', level: 1, hp: 10, maxHp: 10},\n    {name: 'Char 2', className: 'Thief', level: 1, hp: 8, maxHp: 8},\n    {name: 'Char 3', className: 'Priest', level: 1, hp: 8, maxHp: 8},\n    {name: 'Char 4', className: 'Wizard', level: 1, hp: 4, maxHp: 4}\n];\n\n\nvar widths = {\n    name: 80,\n    class: 70,\n    level: 35,\n    hp: 60\n};\n\n\nfunction update(delta) {\n    // no update yet\n}\n\n\nfunction render(rect) {\n    var margin = 0;\n\n    var x = rect.x + margin;\n    var y = rect.y + margin;\n\n    text.drawText('Name', x, y, 'green');\n    x += widths.name;\n\n    text.drawText('HP', x, y, 'green');\n    x += widths.hp;\n\n    text.drawText('Class', x, y, 'green');\n    x += widths.class;\n\n    text.drawText('Level', x, y, 'green');\n    x += widths.level;\n\n    y += 12;\n    for (var i = 0; i < party.length; i++) {\n        drawCharacter(party[i], rect.x + margin, y + (i * 10));\n    }\n}\n\n\nfunction drawCharacter(character, x, y) {\n    var ox = x;\n    var oy = y;\n\n    text.drawText(character.name, x, y);\n    x += widths.name;\n\n    text.drawText(character.hp + '/' + character.maxHp, x, y);\n    x += widths.hp;\n\n    text.drawText(character.className, x, y);\n    x += widths.class;\n\n    text.drawText(character.level + '', x, y);\n    x += widths.level;\n\n}\n\n\n","/**\n * Created by john on 3/24/15.\n */\n\n'use strict';\n\nvar hud = module.exports = {};\n\nvar characterDisplay = require('./characterDisplay');\nvar canvas = require('../canvas'),\n    images = require('../images'),\n    input = require('../input'),\n    text = require('../text');\n\nhud.drawMore = drawMore;\nhud.message = '';\nhud.render = render;\nhud.setMessage = setMessage;\nhud.update = update;\n\nvar messageColor = 'green';\n\nfunction update(delta) {\n    characterDisplay.update(delta);\n}\n\nfunction render() {\n    if (hud.message) {\n        text.drawCentered(hud.message, 10, messageColor);\n    }\n\n    characterDisplay.render({x: 30, y: 240 - 65, w: 310, h: 60});\n}\n\n\nfunction setMessage(message, color) {\n    hud.message = message;\n    canvas.redraw = true;\n\n    messageColor = color || 'green';\n}\n\n\nfunction drawMore(x) {\n    images.drawImage('moreArrow', x, 14);\n}\n","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar imageExports = module.exports = {};\n\n\nvar canvas = require('./canvas');\nvar ctx = canvas.context;\n\nvar totalImages = 9999;\nvar loadedImages = 0;\nvar loaded = false;\n\nvar images = {};\n\n\nimages.wallTexture = loadImage('walltexture');\nimages.floorTexture = loadImage('floortexture');\n\n//images.title = loadImage('title');\n\nimages.borderUL = loadImage('textborder', {x: 0, y: 0, w: 16, h: 16});\nimages.borderU = loadImage('textborder', {x: 16, y: 0, w: 16, h: 16});\nimages.borderUR = loadImage('textborder', {x: 32, y: 0, w: 16, h: 16});\nimages.borderL = loadImage('textborder', {x: 0, y: 16, w: 16, h: 16});\nimages.borderM = loadImage('textborder', {x: 16, y: 16, w: 16, h: 16});\nimages.borderR = loadImage('textborder', {x: 32, y: 16, w: 16, h: 16});\nimages.borderBL = loadImage('textborder', {x: 0, y: 32, w: 16, h: 16});\nimages.borderB = loadImage('textborder', {x: 16, y: 32, w: 16, h: 16});\nimages.borderBR = loadImage('textborder', {x: 32, y: 32, w: 16, h: 16});\n\n//images.room = loadImage('mapTiles', {x: 16, y: 0, w: 16, h: 16});\n//images.visitedroom = loadImage('mapTiles', {x: 0, y: 0, w: 16, h: 16});\n//images.currentPos = loadImage('mapTiles', {x: 22, y: 22, w: 4, h: 4});\n//images.hCorridor = loadImage('mapTiles', {x: 32, y: 6, w: 4, h: 4});    // real width=16\n//images.vCorridor = loadImage('mapTiles', {x: 6, y: 16, w: 4, h: 4});    // real height=16\n//images.stairsUp = loadImage('mapTiles', {x: 32, y: 16, w: 16, h: 16});\n\nimages.selectionArrow = loadImage('selectionarrow', {x: 0, y: 0, w: 3, h: 6});\nimages.moreArrow = loadImage('more_arrow', {x:1, y:0, w:5, h: 3});\nimages.skull = loadImage('skull', {x: 0, y: 0, w: 50, h: 50});\n\n\n// get total number of images to make sure we've loaded everything\ntotalImages = Object.keys(images).length;\nif (checkLoadComplete()) loaded = true;\n\n\nimageExports.drawBorder = drawBorder;\nimageExports.drawImage = drawImage;\nimageExports.getBorder = getBorder;\nimageExports.images = images;\nimageExports.isLoaded = function isLoaded() {\n    return loaded;\n};\nimageExports.loadPct = function loadPct() {\n    return loadedImages / totalImages;\n};\nimageExports.withContext = withContext;\n\n////////////////////////////////////////\n\n\nfunction onLoad() {\n    loadedImages++;\n    if (checkLoadComplete()) {\n        loaded = true;\n    }\n}\n\nfunction checkLoadComplete() {\n    return loadedImages >= totalImages;\n}\n\n\nfunction drawBorder(rect) {\n    if (!loaded) return;\n    var x = rect.x,\n        y = rect.y,\n        w = rect.w,\n        h = rect.h;\n\n    var borderSize = 16;\n\n    var bottomRow = (y + h) - borderSize;\n    var rightCol = (x + w) - borderSize;\n\n    // take advantage of the fact that the border graphics are one color so we can stretch them\n\n    drawImage('borderM', rect.x, rect.y, rect.w, rect.h);\n    drawImage('borderU', rect.x, rect.y, rect.w, borderSize);\n    drawImage('borderL', rect.x, rect.y, borderSize, rect.h);\n    drawImage('borderR', rightCol, rect.y, borderSize, rect.h);\n    drawImage('borderB', rect.x, bottomRow, rect.w, borderSize);\n\n    drawImage('borderUL', x, y);\n    drawImage('borderUR', rightCol, y);\n    drawImage('borderBL', x, bottomRow);\n    drawImage('borderBR', rightCol, bottomRow);\n}\n\n\nfunction drawImage(image, x, y, w, h) {\n    if (!loaded) return;\n\n    var img = typeof(image) === 'object' ? image : images[image];\n    w = w || img.sw;\n    h = h || img.sh;\n\n\n    if (img.sx !== undefined && img.sy !== undefined) {\n        ctx.drawImage(img, img.sx, img.sy, img.sw, img.sh, x, y, w, h);\n    } else {\n        ctx.drawImage(img, x, y);\n    }\n}\n\n\nfunction getBorder(rect) {\n    var config = require('./config');\n\n    console.log('getBorder');\n    console.log(rect);\n\n    var cnv = canvas.createNewCanvas(config.width, config.height);\n    var context = cnv.getContext(\"2d\");\n\n    // switch the context around and draw to the new canvas, then switch it back\n    var r2 = {x: 0, y: 0, w: rect.w, h: rect.h};\n    withContext(context, function () {\n        drawBorder(r2);\n    });\n    //setContext(context);\n    //setContext(canvas.context);\n    return cnv;\n}\n\n\nfunction loadImage(image, src) {\n    var img = new Image();\n    img.onload = onLoad;\n    img.src = '/images/' + image + '.png';\n    if (src) {\n        img.sx = src.x;\n        img.sy = src.y;\n        img.sw = src.w;\n        img.sh = src.h;\n    }\n    return img;\n}\n\n\nfunction withContext(context, action) {\n    setContext(context);\n    action();\n    setContext(canvas.context);\n}\n\n\nfunction setContext(context) {\n    ctx = context;\n}","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\nmodule.exports = {\n    //clickPos: clickPos,\n    //getMouseClick: getMouseClick,\n    //isClicked: isClicked,\n    //isMouseOver: isMouseOver,\n\n    keyDown: isKeyDown,\n    handleKey: handleKey,\n\n    //mousePos: mousePos,\n    //mousePressed: mousePressed,\n\n    processedKey: isKeyHandled,\n    registerEventHandlers: registerEventHandlers\n};\n\n\nvar config = require('./config'),\n    element = require('./canvas').element,\n    utils = require('./utils');\n\n\nvar KEYCODE = {\n    // these are the arrow keys\n    ARROW_UP: 38,\n    ARROW_DOWN: 40,\n    ARROW_LEFT: 37,\n    ARROW_RIGHT: 39,\n\n    // these are WASD keys\n    UP: 87,\n    DOWN: 83,\n    LEFT: 65,\n    RIGHT: 68,\n    SPACE: 32,\n\n    ESC: 27,\n    ENTER: 13,\n    M: 77       // 'M' for mini-map\n};\n\n\nvar keyMappings = [\n    {key: 'up', code: KEYCODE.UP},\n    {key: 'down', code: KEYCODE.DOWN},\n    {key: 'left', code: KEYCODE.LEFT},\n    {key: 'right', code: KEYCODE.RIGHT},\n    {key: 'action', code: KEYCODE.SPACE},\n    {key: 'cancel', code: KEYCODE.ESC},\n    {key: 'confirm', code: KEYCODE.ENTER},\n\n    {key: 'a_up', code: KEYCODE.ARROW_UP},\n    {key: 'a_down', code: KEYCODE.ARROW_DOWN},\n    {key: 'a_left', code: KEYCODE.ARROW_LEFT},\n    {key: 'a_right', code: KEYCODE.ARROW_RIGHT},\n\n    {key: 'map', code: KEYCODE.M}\n];\n\nvar mousePressed = {\n    left: false,\n    right: false\n};\n\nvar preventInput = {\n    left: false,\n    right: false\n};\n\nvar keyDown = {\n    left: false,\n    right: false,\n    up: false,\n    down: false\n};\n\nvar processedKey = {\n    left: false,\n    right: false,\n    up: false,\n    down: false,\n    action: false\n};\n\n\nvar mousePos = {x: 0, y: 0};\nvar clickPos = null;\n\n\nfunction handleMouseDown(evt) {\n    evt.preventDefault();\n    mousePressed.left = true;\n    clickPos = clickCoord(evt);\n}\n\nfunction handleMouseUp(evt) {\n    mousePressed.left = false;\n    preventInput.left = false;\n    clickPos = null;\n}\n\nfunction handleMouseOver(evt) {\n    mousePos = clickCoord(evt);\n}\n\nfunction clickCoord(evt) {\n\n    var canx;\n    var cany;\n\n    if (evt.pageX || evt.pageY) {\n        canx = evt.pageX;\n        cany = evt.pageY;\n    }\n    else {\n        canx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n        cany = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n    }\n    canx -= element.offsetLeft;\n    cany -= element.offsetTop;\n\n    canx /= config.scale;\n    cany /= config.scale;\n\n    return {x: canx, y: cany};\n}\n\n/** Touch Handler **/\n\nfunction handleTouchStart(evt) {\n    evt.preventDefault();\n    mousePressed.left = true;\n    mousePos = touchCoord(evt);\n}\n\n\nfunction handleTouchEnd(evt) {\n    mousePressed.left = false;\n    preventInput.left = false;\n}\n\n\nfunction handleKeyDown(evt) {\n    var processed = false;\n    keyMappings.forEach(function (mapping) {\n\n        if (!processed && evt.keyCode === mapping.code) {\n            keyDown[mapping.key] = true;\n            evt.preventDefault();\n\n            processed = true;\n        }\n    });\n}\n\n\nfunction handleKeyUp(evt) {\n    var processed = false;\n    keyMappings.forEach(function (mapping) {\n\n        if (!processed && evt.keyCode === mapping.code) {\n            keyDown[mapping.key] = false;\n            processedKey[mapping.key] = false;\n\n            processed = true;\n        }\n    });\n}\n\n\nfunction registerEventHandlers() {\n    if (window.addEventListener) {\n        window.addEventListener('keydown', handleKeyDown, true);\n        window.addEventListener('keyup', handleKeyUp, true);\n        window.addEventListener('mousedown', handleMouseDown, true);\n        window.addEventListener('mouseup', handleMouseUp, true);\n        window.addEventListener('mousemove', handleMouseOver, true);\n        window.addEventListener('touchstart', handleTouchStart, true);\n        window.addEventListener('touchend', handleTouchEnd, true);\n    }\n}\n\n\n/**\n * Returns true if the mouse is down within the specified rectangle\n * @param rect\n */\nfunction isClicked(rect) {\n    if (!rect) return false;\n    if (preventInput.left) {\n        console.log(\"preventinput\");\n        return false;\n    }\n\n    var clicked = mousePressed.left && isMouseOver(rect);\n    if (clicked) {\n        // make sure we don't process 2 clicks in 2 subsequent frames if the button is held down\n        mousePressed.left = false;\n    }\n    return clicked;\n}\n\n\nfunction getMouseClick() {\n    if (preventInput.left) return false;\n\n    var clicked = mousePressed.left;\n    if (clicked) {\n        mousePressed.left = false;\n        return clickPos;\n    }\n    return null;\n}\n\n\nfunction touchCoord(evt) {\n    var canx = evt.touches[0].pageX;\n    var cany = evt.touches[0].pageY;\n\n    canx -= element.offsetLeft;\n    cany -= element.offsetTop;\n\n    canx /= config.scale;\n    cany /= config.scale;\n\n    return {x: canx, y: cany};\n}\n\nfunction handleKey(key, processed) {\n    processedKey[key] = processed;\n}\n\nfunction isMouseOver(rect) {\n    if (!rect) return false;\n    return utils.isWithin(mousePos, rect);\n}\n\nfunction isKeyDown(key, processed) {\n    return keyDown[key] && (!processed || !isKeyHandled(key));\n}\n\nfunction isKeyHandled(key) {\n    return processedKey[key];\n}\n\n","/**\n * Created by john on 3/22/15.\n */\n\nvar atlas = module.exports = {};\n\n\nvar map2 = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1],\n    [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1],\n    [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n    [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1],\n    [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1],\n    [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],\n    [1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1],\n    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],\n    [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n];\n\n\nvar maps = [\n    {\n        name: 'Starting map',\n        data: map2,\n        encounterIncrement: 0.05,\n        //rooms: initialize(map),\n        ////startRoom: {x: 2, y: 2},\n        startRoom: {x: 0, y: 3},\n        maxEncounterChance: 0.6\n    }\n];\n\n\natlas.maps = maps;\n","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nmodule.exports = {\n    getMapGeometry: getMapGeometry\n};\n\nvar textures = require('../textures');\n\n/**\n * Returns two meshes for the map itself and the floor\n * @param map\n * @returns {{mesh: *, floor: *}}\n */\nfunction getMapGeometry(map) {\n    return {\n        mesh: getMapMesh(map),\n        floor: getFloor(map),\n        ceiling: getCeiling(map)\n    };\n}\n\n\n/**\n * Translate all points in a geometry `n` units in the x direction.\n */\nfunction transX(geo, n) {\n    for (var i = 0; i < geo.vertices.length; i++) {\n        geo.vertices[i].x += n;\n    }\n}\n\n/**\n * Translate all points in a geometry `n` units in the z direction.\n */\nfunction transZ(geo, n) {\n    for (var i = 0; i < geo.vertices.length; i++) {\n        geo.vertices[i].z += n;\n    }\n}\n\n\n/**\n * Returns a mesh representing the floor of the current level.\n * @param map\n * @returns {THREE.Mesh}\n */\nfunction getFloor(map) {\n\n    var width = map[0].length;\n    var height = map.length;\n    var cellSize = 200;\n\n    var texture = textures.getTexture('floor');\n    texture.minFilter = THREE.NearestFilter;\n    texture.magFilter = THREE.NearestFilter;\n\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n\n    texture.repeat.set(width * 1, height * 1);\n    texture.needsUpdate = true;\n\n    var material = new THREE.MeshPhongMaterial({map: texture, doubleSided: true, side: THREE.DoubleSide});\n    var geometryPlane = new THREE.PlaneBufferGeometry(width * 1 * cellSize, height * 1 * cellSize);\n    var plane = new THREE.Mesh(geometryPlane, material);\n\n    plane.rotation.x = -Math.PI / 2;\n    plane.position.y = -100;    // center is at 0, height is 200\n    plane.position.x = (width / 2) * cellSize;\n    plane.position.z = (height / 2) * cellSize;\n\n    return plane;\n}\n\n\nfunction getCeiling(map) {\n    var width = map[0].length;\n    var height = map.length;\n    var cellSize = 200;\n\n    var texture = textures.getTexture('floor');\n    texture.minFilter = THREE.NearestFilter;\n    texture.magFilter = THREE.NearestFilter;\n\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n\n    texture.repeat.set(width * 1, height * 1);\n    texture.needsUpdate = true;\n\n    var material = new THREE.MeshPhongMaterial({map: texture, doubleSided: true, side: THREE.DoubleSide});\n    var geometryPlane = new THREE.PlaneBufferGeometry(width * 1 * cellSize, height * 1 * cellSize);\n    var plane = new THREE.Mesh(geometryPlane, material);\n\n    plane.rotation.x = -Math.PI / 2;\n    plane.position.y = 100;    // center is at 0, height is 200\n    plane.position.x = (width / 2) * cellSize;\n    plane.position.z = (height / 2) * cellSize;\n\n    return plane;\n}\n\n\n/**\n * Returns a mesh representing the maze geometry of the current level.\n * @param map\n * @returns {THREE.Mesh}\n */\nfunction getMapMesh(map) {\n    var geometry, material, mesh;\n    var img = textures.getTexture('wall');\n    img.minFilter = THREE.NearestFilter;\n    img.magFilter = THREE.NearestFilter;\n\n    geometry = new THREE.BoxGeometry(200, 200, 200);\n    material = new THREE.MeshLambertMaterial({color: 0xaabbaa, wireframe: false, map: img});\n\n    var height = map.length;\n    var width = map[0].length;\n\n    for (var j = 0; j < height; j++) {\n        for (var i = 0; i < width; i++) {\n\n            if (map[j][i] === 1) {\n                var tmp = new THREE.BoxGeometry(200, 200, 200);\n                transX(tmp, i * 200);\n                transZ(tmp, j * 200);\n\n                geometry.merge(tmp);\n            }\n\n        }\n    }\n\n    mesh = new THREE.Mesh(geometry, material);\n    return mesh;\n}\n\n\n","/**\n * Created by john on 3/26/15.\n */\n\n'use strict';\n\nmodule.exports = Menu;\n\nvar\n    images = require('../images'),\n    input = require('../input'),\n    player = require('../player'),\n    sounds = require('../sounds'),\n    text = require('../text'),\n    utils = require('../utils')\n    ;\n\n\nfunction Menu(sizeRect, options) {\n    this.border = images.getBorder(sizeRect);\n    this.options = [];\n    this.parentMenu = options.parent || null;   // when cancel is pressed, what menu to go back to\n    this.selectedIndex = 0;\n    this.size = sizeRect;\n    this.subMenu = null;    // display a sub menu\n\n    var xPos = 5,\n        yPos = 0,\n        self = this;\n\n    options.forEach(function (o) {\n        var opt = utils.extend(o, {\n            menu: self,\n            x: xPos + 2,\n            y: yPos += 10\n        });\n        self.options.push(opt);\n    });\n}\n\n\nMenu.prototype.render = function () {\n    var self = this;\n    images.drawImage(this.border, this.size.x, this.size.y);\n\n    for (var i = 0; i < this.options.length; i++) {\n        var o = this.options[i],\n            xPos = o.x + self.size.x,\n            yPos = o.y + self.size.y;\n\n        if (this.selectedIndex === i) {\n            images.drawImage('selectionArrow', xPos, yPos);\n            xPos += 5;\n        }\n        text.drawText(o.title, xPos, yPos);\n    }\n};\n\n\nMenu.prototype.update = function (delta) {\n    // process keys etc\n    if (player.getState() !== player.states.INPUT) {\n        return false;\n    }\n\n    if (input.keyDown('a_up', true)) {\n        input.handleKey('a_up', true);\n        this.selectedIndex--;\n        sounds.playSound('MENU_MOVE');\n\n    } else if (input.keyDown('a_down', true)) {\n        input.handleKey('a_down', true);\n        this.selectedIndex++;\n        sounds.playSound('MENU_MOVE');\n\n    } else if (input.keyDown('confirm', true)) {\n        input.handleKey('confirm', true);\n\n        var item = this.options[this.selectedIndex];\n        if (item && item.action) {\n            //sounds.playSound('MENU_SELECT');\n            item.action();\n        }\n\n    } else if (input.keyDown('cancel', true)) {\n        input.handleKey('cancel', true);\n\n        if (this.parentMenu) {\n            // go back to parent menu\n        }\n    }\n\n\n    if (this.selectedIndex < 0) {\n        this.selectedIndex = this.options.length - 1;\n    }\n    this.selectedIndex = this.selectedIndex % this.options.length;\n};\n","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar player = module.exports = {\n    currentMap: 0,\n    direction: 0,\n    flags: []\n};\n\n\nvar states = {\n        MOVING: 0,\n        TURNING: 1,\n        INPUT: 2,\n        NO_MOVE: 3\n    },\n    currentState = states.INPUT;\n\n\nplayer.direction = Math.PI;\nplayer.hasFlag = hasFlag;\nplayer.position = {x: 3, y: 3};\nplayer.setFlag = setFlag;\nplayer.states = states;\n\n\nplayer.getState = function getState() {\n    return currentState;\n};\n\nplayer.setState = function setState(state) {\n    currentState = state;\n};\n\n\nfunction hasFlag(flag) {\n    return player.flags.indexOf(flag) >= 0;\n}\n\n\nfunction setFlag(flag) {\n    player.flags.push(flag);\n}","/**\n * Created by john on 3/22/15.\n *\n * This module renders the view using Three.js\n */\n\n'use strict';\n\nvar viewRenderer = module.exports = {\n    getDimensions: function () {\n        return {\n            width: wWidth,\n            height: wHeight,\n            aspect: aspect\n        };\n    },\n    getElement: function () {\n        return domElement;\n    },\n    initialize: initialize,\n    initializeMap: initializeMap,\n    render: render,\n    screenShake: screenShake,\n    update: update,\n\n    getNewObject: createNewPlane\n};\n\n\nviewRenderer.updateHud = function updateHud() {\n    cnvText.needsUpdate = true;\n};\n\nvar constants = {\n    CAMERA_HEIGHT: -40,\n    FLOOR_HEIGHT: -100,\n    MAP_HEIGHT: 0\n};\n\nvar atlas = require('./map/atlas'),\n    canvas = require('./canvas'),\n    config = require('./config'),\n    mapGeometry = require('./map/mapGeometry'),\n    player = require('./player'),\n    utils = require('./utils');\n\n\nvar cnvText;\n\nvar shake = {\n    duration: 0,\n    magnitude: 0\n};\n\nvar scale, wWidth, wHeight, aspect;\n\nvar scene, hudScene,\n    camera, hudCam,\n    hudMesh,\n    renderer,\n    domElement,\n    playerLight;\n\nvar mesh, floor, ceiling;\n\nvar tileSize = 200,\n    WIDTH = config.width,\n    HEIGHT = config.height;\n\n\nfunction initialize() {\n\n    scale = Math.floor(window.innerHeight / HEIGHT);    // scale to the available vertical space\n    wWidth = WIDTH * scale;\n    wHeight = HEIGHT * scale;\n    aspect = wWidth / wHeight;\n\n    cnvText = new THREE.Texture(canvas.element);\n    cnvText.needsUpdate = true;\n    cnvText.minFilter = THREE.NearestFilter;\n    cnvText.magFilter = THREE.NearestFilter;\n\n\n    scene = new THREE.Scene();\n    hudScene = new THREE.Scene();\n\n    camera = new THREE.PerspectiveCamera(70, aspect, 1, 10000);\n    camera.position.y = constants.CAMERA_HEIGHT;\n\n    var width = wWidth;\n    var height = wHeight;\n\n    hudCam = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 10000);\n    hudCam.position.z = 100;\n\n    var planeGeom = new THREE.PlaneBufferGeometry(wWidth, wHeight);\n    var textMater = new THREE.MeshBasicMaterial({\n        map: cnvText,\n        color: 0xffffff,\n        transparent: true\n    });\n\n\n    hudMesh = new THREE.Mesh(planeGeom, textMater);\n    hudMesh.lookAt(hudCam.position); // Rotate the mesh so the face is fully visible by the camera\n    hudScene.add(hudMesh);\n\n    renderer = new THREE.WebGLRenderer({antialiasing: false});\n\n\n    renderer.setSize(wWidth, wHeight);\n    renderer.setClearColor(0x0088FF, 1);\n    renderer.autoClear = false;\n\n    domElement = renderer.domElement;\n\n\n    playerLight = new THREE.PointLight(0xaaaaaa);\n    playerLight.castShadow = true;\n    playerLight.shadowMapWidth = 128;\n    playerLight.shadowMapHeight = 128;\n    playerLight.shadowCameraNear = 1;\n    playerLight.shadowCameraFar = 100; //XXX: That should be far enough.\n    playerLight.shadowCameraFov = 90;\n    playerLight.shadowDarkness = 0.75; //XXX: Can change later...\n    playerLight.intensity = 2.5;\n    playerLight.angle = Math.PI / 2;\n    playerLight.distance = 200 * 8;\n\n    scene.add(camera);\n\n    // add the light to the camera, so it always points in the same direction\n    camera.add(playerLight);\n\n}\n\n\nfunction initializeMap() {\n    clearScene();\n\n    var geometry = mapGeometry.getMapGeometry(atlas.maps[0].data);\n\n    mesh = geometry.mesh;\n    floor = geometry.floor;\n    ceiling = geometry.ceiling;\n\n    scene.add(mesh);\n    scene.add(floor);\n    scene.add(ceiling);\n\n    mesh.position.y = 0;\n\n    renderer.render(scene, camera);\n    renderer.render(hudScene, hudCam);\n\n}\n\n\nfunction update(delta) {\n    camera.rotation.y = player.direction;\n\n    camera.position.y = constants.CAMERA_HEIGHT;\n    camera.position.z = tileSize * player.position.y;   // z-coord: fwd/back\n    camera.position.x = tileSize * player.position.x;   // x-coord: left/right\n\n    if (mesh) {\n        mesh.position.y = constants.MAP_HEIGHT;\n    }\n\n    // screen shake\n    if (shake.duration > 0) {\n\n        camera.position.y += (Math.random() * shake.magnitude) - (shake.magnitude / 2);\n        camera.position.x += (Math.random() * shake.magnitude) - (shake.magnitude / 2);\n        camera.position.z += (Math.random() * shake.magnitude) - (shake.magnitude / 2);\n\n        //if (mesh && floor) {\n        //    var yAmt = (Math.random() * shake.magnitude) - (shake.magnitude / 2);\n        //    mesh.position.y += yAmt;\n        //    floor.position.y += yAmt;\n        //    //camera.position.x += (Math.random() * shake.magnitude) - (shake.magnitude / 2);\n        //    //camera.position.z += (Math.random() * shake.magnitude) - (shake.magnitude / 2);\n        //}\n\n        shake.duration--;\n    }\n}\n\n\nfunction render() {\n\n    renderer.render(scene, camera);\n    renderer.render(hudScene, hudCam);\n}\n\n\nfunction clearScene() {\n    // remove everything but the camera/light, since it was added as the first child\n    for (var i = scene.children.length - 1; i > 0; i--) {\n        scene.remove(scene.children[i]);\n    }\n}\n\n\nfunction screenShake(duration, magnitude) {\n    shake.magnitude = magnitude || 10;\n    shake.duration = duration;\n}\n\n\nfunction createNewPlane() {\n    function PlaneObject() {\n        var width = config.width;\n        var height = config.height;\n        var cellSize = 200;\n\n        var cnv = document.createElement('canvas');\n        cnv.width = width;\n        cnv.height = height;\n\n        this.context = cnv.getContext(\"2d\");\n        this.dispose = function () {\n            scene.remove(plane);\n            plane.geometry.dispose();\n            plane.material.dispose();\n        };\n        this.needsUpdate = function () {\n            cText.needsUpdate = true;\n        };\n\n\n        var cText = new THREE.Texture(cnv);\n        cText.needsUpdate = true;\n        cText.minFilter = THREE.NearestFilter;\n        cText.magFilter = THREE.NearestFilter;\n\n\n        var texture = require('./textures').getTexture('floor');\n        texture.minFilter = THREE.NearestFilter;\n        texture.magFilter = THREE.NearestFilter;\n\n        texture.needsUpdate = true;\n\n        //var material = new THREE.MeshLambertMaterial({map: texture, doubleSided: true, side: THREE.DoubleSide});\n        var material = new THREE.MeshBasicMaterial({\n            map: cText, doubleSided: true, side: THREE.DoubleSide, color: 0xffffff,\n            transparent: true\n        });\n        var geometryPlane = new THREE.PlaneBufferGeometry(width, height);\n        var plane = new THREE.Mesh(geometryPlane, material);\n\n        // makes it face the same direction as the player\n        var vect = require('./utils').directionToVector(player.direction);\n\n        plane.rotation.y = player.direction;\n        plane.position.y = 0;    // center is at 0, height is 200\n        plane.position.x = (player.position.x * cellSize) + (-vect.x * cellSize / 2);\n        plane.position.z = (player.position.y * cellSize) + (-vect.y * cellSize / 2);\n\n        scene.add(plane);\n\n    }\n\n    return new PlaneObject();\n}","/**\n * Created by john on 3/28/15.\n */\n\n'use strict';\n\nmodule.exports = Battle;\n\n\nvar activeMap = require('../../activeMap'),\n    config = require('../../config'),\n    Enemy = require('./Enemy'),\n    hud = require('../../hud'),\n    input = require('../../input'),\n    Menu = require('../../menu'),\n    sounds = require('../../sounds'),\n    utils = require('../../utils');\n\nvar rowPositionsX = [\n    [\n        [130],\n        [100, 160],\n        [70, 140, 210],\n        [60, 110, 160, 210]\n    ],\n    [\n        [135],\n        [95, 155],\n        [75, 145, 215],\n        [65, 115, 165, 215]\n    ]\n];\n\nvar rowPositionsY = [80, 70, 65];\nvar plane;\n\nvar states = {\n    FIGHT: 0,\n    ESCAPED: 1\n};\n\nvar endBattleCounter = 0;\n\n\n/**\n * Represents the current battle. A new one gets created and assigned to currentBattle each time combat.init() is called\n * @constructor\n */\nfunction Battle(combat) {\n    var self = this;\n    var map = activeMap.getCurrentMap();\n    //plane = renderer.getNewObject();\n\n    this.combat = combat;\n    this.enemies = initializeEnemies();\n    this.menu = new Menu({\n        x: 150,\n        y: config.height - 70,\n        w: config.width - 180,\n        h: 60\n    }, [\n        {title: 'Fight'},\n        {\n            title: 'Run',\n            action: function () {\n                self.run();\n            }\n        },\n        {title: '9/9/9/9/9/9/9/9/9'},\n        {title: 'Skill'}\n    ]);\n    this.state = states.FIGHT;\n\n\n    function initializeEnemies() {\n        var enemies = [];\n        var numRows = utils.randomBetween(1, 2);\n        for (var r = 0; r < numRows; r++) {\n            var numEnemies = utils.randomBetween(1, 4);\n            var row = [];\n            var xPos = rowPositionsX[r][numEnemies - 1];\n\n            for (var e = 0; e < numEnemies; e++) {\n                var x = xPos[e];\n                var y = rowPositionsY[r];\n\n                var enemy = new Enemy({image: 'skull'}, x, y);\n                row.push(enemy);\n            }\n            enemies.push(row);\n        }\n        return enemies;\n    }\n}\n\nBattle.prototype.update = function (delta) {\n    switch (this.state) {\n        case states.FIGHT:\n            for (var i = this.enemies.length - 1; i >= 0; i--) {\n                for (var j = 0; j < this.enemies[i].length; j++) {\n                    var enemy = this.enemies[i][j];\n                    if (enemy.isAlive) {\n                        enemy.update(delta);\n                    }\n                }\n            }\n            this.menu.update(delta);\n            break;\n\n        case states.ESCAPED:\n            //var ctx = require('../../canvas').context;\n            //if (endBattleCounter < 99) {\n            //    endBattleCounter++;\n            //}\n            //if (endBattleCounter > 0) {\n            //    ctx.globalAlpha = 1 / (endBattleCounter + 1);\n            //}\n            if (input.keyDown('confirm', true) || input.keyDown('action', true) || input.keyDown('cancel', true)) {\n                //ctx.globalAlpha = 1;\n                this.combat.endBattle();\n            }\n            break;\n    }\n\n};\n\nBattle.prototype.render = function () {\n    //var img = images.images.skull;\n    //var ctx = plane.context;\n    //ctx.drawImage(img, 60, 50);\n    //plane.needsUpdate();\n\n    switch (this.state) {\n        case states.FIGHT:\n            for (var i = this.enemies.length - 1; i >= 0; i--) {\n                for (var j = 0; j < this.enemies[i].length; j++) {\n                    var enemy = this.enemies[i][j];\n                    if (enemy.isAlive) {\n                        enemy.draw(i);\n                    }\n                }\n            }\n            this.menu.render();\n            break;\n\n        case states.ESCAPED:\n\n            break;\n    }\n\n};\n\n\nBattle.prototype.dispose = function () {\n    //plane.dispose();\n};\n\n\nBattle.prototype.run = function () {\n    // check if we can run\n    if (Math.random() <= 0.5) {\n        hud.setMessage(\"You managed to escape.\");\n        hud.drawMore(200);\n        sounds.playSound('RUN');\n        this.state = states.ESCAPED;\n\n    } else {\n        hud.setMessage(\"Can't run!\", 'red');\n        sounds.playSound('NO_RUN');\n    }\n};","/**\n * Created by john on 3/26/15.\n */\n\n'use strict';\n\nmodule.exports = Enemy;\n\n\nvar canvas = require('../../canvas'),\n    images = require('../../images'),\n    utils = require('../../utils');\n\nvar context = canvas.context;\n\n\nfunction Enemy(definition, x, y) {\n    definition = definition || {};\n\n    this.image = definition.image || 'skull';\n    this.isAlive = true;\n    this.level = 1;\n    this.name = definition.name || 'Skull';\n    this.position = {x: x, y: y};\n\n    this.onUpdate = definition.onUpdate || getDefaultOnUpdate(this);\n}\n\n\nEnemy.prototype.update = function (delta) {\n\n    this.onUpdate(delta);\n};\n\n\nEnemy.prototype.draw = function (row) {\n    context.globalAlpha = 1 / ((row + 1));\n    images.drawImage(this.image, Math.round(this.position.x), Math.round(this.position.y));\n    context.globalAlpha = 1;\n};\n\n\n/**\n * Default update behavior, just moves the sprite up and down between a min and max y-value\n * @param enemy\n * @returns {Function}\n */\nfunction getDefaultOnUpdate(enemy) {\n    var yBounds = {\n        min: enemy.position.y - Math.ceil(Math.random() * 3) + 2,\n        max: enemy.position.y + Math.ceil(Math.random() * 3) + 2\n    };\n    var dir = Math.round(Math.random() * 2) - 1;\n    if (dir === 0) dir = -1;\n\n    return function defaultOnUpdate(delta) {\n        var amount = utils.clamp(delta * 10, 0, 1);\n        if (dir === 1) {\n            if (enemy.position.y < yBounds.max) {\n                enemy.position.y += amount;\n            } else {\n                dir = -1;\n            }\n\n        } else if (dir === -1) {\n            if (enemy.position.y > yBounds.min) {\n                enemy.position.y -= amount;\n            } else {\n                dir = 1;\n            }\n        }\n    };\n}","/**\n * Created by john on 3/25/15.\n */\n\n\n'use strict';\n\n\nvar combat = module.exports = {\n    nextState: 'BATTLE',\n    update: update,\n    render: render,\n    endBattle: endBattle\n};\n\ncombat.init = function initialize() {\n    console.log(\"New battle!\");\n    sounds.playSound('START_BATTLE');\n    currentBattle = new Battle(combat);\n\n    combat.nextState = 'BATTLE';\n};\n\ncombat.getBattle = function getBattle() {\n    return currentBattle;\n};\n\n\nvar\n    Battle = require('./Battle'),\n    canvas = require('../../canvas'),\n    config = require('../../config'),\n    hud = require('../../hud'),\n    images = require('../../images'),\n    input = require('../../input'),\n    player = require('../../player'),\n    renderer = require('../../renderer'),\n    sounds = require('../../sounds'),\n    utils = require('../../utils')\n    ;\n\nvar dims = {\n    width: config.width,\n    height: config.height\n};\n\n\nvar currentBattle = null;\n\n\nfunction update(delta) {\n    processKeys();\n\n    if (currentBattle) {\n        currentBattle.update(delta);\n        canvas.redraw = true;\n    }\n    hud.update(delta);\n}\n\n\nfunction render() {\n\n    // dim the background\n    var ctx = canvas.context;\n    ctx.globalAlpha = 0.2;\n    ctx.fillStyle = 'rgb(30,30,40)';\n    ctx.fillRect(0, 0, 320, 240);\n    ctx.globalAlpha = 1;\n\n\n    images.drawBorder({x: 30, y: 40, w: dims.width - 60, h: 120});\n\n    if (currentBattle) {\n        currentBattle.render();\n    }\n}\n\n\nfunction processKeys() {\n    if (player.getState() !== player.states.INPUT) {\n        return false;\n    }\n\n    if (input.keyDown('action', true)) {\n        input.handleKey('action', true);\n\n        hud.setMessage(\"action key pressed\");\n\n        renderer.screenShake(20, 30);\n\n    } else if (input.keyDown('cancel', true)) {\n\n    }\n}\n\n\nfunction endBattle() {\n    if (currentBattle) currentBattle.dispose();\n    combat.nextState = 'EXPLORE';\n}","/**\n * Created by john on 3/25/15.\n */\n\n'use strict';\n\n\nvar explore = module.exports = {};\nexplore.init = init;\nexplore.nextState = 'EXPLORE';\nexplore.render = render;\nexplore.update = update;\n\n\nvar activeMap = require('../../activeMap'),\n    canvas = require('../../canvas'),\n    hud = require('../../hud'),\n    keys = require('./keys'),\n    movement = require('./movement');\n\n\nvar keyHandlers = [\n    {handler: movement, callback: onMoveComplete},\n    {handler: keys}\n];\n\nvar encounterChance = 0;\n\n\nfunction init() {\n    hud.setMessage('');\n    explore.nextState = 'EXPLORE';\n}\n\nfunction update(delta) {\n    var keyPressed = false,\n        existingMessage = hud.message;\n\n    // process any key pressed\n    keyHandlers.forEach(function (i) {\n        if (keyPressed) return;\n\n        var processed = i.handler.processKeys();\n        if (processed) {\n            keyPressed = true;\n        }\n    });\n\n    // clear the displayed message if a key was pressed\n    if (keyPressed && existingMessage) {\n        hud.message = \"\";\n        canvas.redraw = true;\n    }\n\n    // update all key handlers\n    keyHandlers.forEach(function (i) {\n        i.handler.update(delta, i.callback);\n    });\n\n    hud.update(delta);\n}\n\n\nfunction render() {\n\n}\n\n\nfunction onMoveComplete(moved) {\n    if (!moved) {\n        hud.setMessage(\"There is a wall there!\", 'red');\n\n    } else {\n        // check for random battles, events on the tile, etc\n        var currentMap = activeMap.getCurrentMap();\n\n        encounterChance += currentMap.encounterIncrement;\n        encounterChance = Math.min(encounterChance, currentMap.maxEncounterChance);\n\n        if (Math.random() < encounterChance) {\n            hud.setMessage('Something approaches!');\n            console.log(\"Battle! pct=\" + encounterChance);\n\n            // enter battle!\n            encounterChance = 0;\n            explore.nextState = 'BATTLE';\n        }\n\n    }\n\n    canvas.redraw = true;\n}","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\nvar dungeon = module.exports = {};\n\nvar canvas = require('../../canvas'),\n    config = require('../../config'),\n    hud = require('../../hud'),\n    input = require('../../input'),\n    keys = require('./keys'),\n    renderer = require('../../renderer'),\n    text = require('../../text');\n\n\nvar states = {\n        EXPLORE: require('./explore'),\n        BATTLE: require('./combat'),\n        MENU: {}\n    },\n    currentState = states.EXPLORE;\n\n\n/**\n * @description     Updates each frame\n */\ndungeon.update = function update(delta) {\n\n    currentState.update(delta);\n\n    var nextState = states[currentState.nextState];\n\n    if (nextState !== currentState) {\n        currentState = nextState;\n        if (currentState.init) {\n            currentState.init();\n        }\n\n        // always redraw on state changes\n        canvas.redraw = true;\n    }\n};\n\n\n/**\n * @description     Renders the view\n */\ndungeon.render = function render() {\n\n    hud.render();\n    currentState.render();\n\n    renderer.updateHud();\n};","/**\n * Created by john on 3/25/15.\n */\n\n'use strict';\n\nvar keys = module.exports = {};\n\nvar canvas = require('../../canvas'),\n    hud = require('../../hud'),\n    input = require('../../input'),\n    player = require('../../player');\n\nvar renderer = require('../../renderer');\n\nkeys.processKeys = processKeys;\nkeys.update = function update(delta) {\n\n};\n\n\nfunction processKeys() {\n    if (player.getState() !== player.states.INPUT) {\n        return false;\n    }\n\n    if (isKeyDown('action')) {\n        input.handleKey('action', true);\n\n        hud.setMessage(\"action key pressed\");\n\n        renderer.screenShake(20, 30);\n    }\n}\n\n\nfunction isKeyDown(key) {\n    return input.keyDown(key) && !input.processedKey(key);\n}","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar movement = module.exports = {};\n\nvar activeMap = require('../../activeMap'),\n    input = require('../../input'),\n    player = require('../../player'),\n    sounds = require('../../sounds'),\n    util = require('../../utils');\n\n\nvar keys = {left: false, right: false, up: false, down: false};\n\nvar turnTo = {\n        from: 0,\n        to: 0,\n        dir: 0\n    },\n    walkTo = {\n        from: 0,\n        to: 0,\n        dir: 0\n    };\n\n\nmovement.processKeys = processKeys;\nmovement.update = update;\n\n\nfunction processKeys() {\n\n    keys = {\n        left: false, right: false, up: false, down: false\n    };\n    if (player.getState() === player.states.INPUT) {\n        var keyPressed = false;\n        for (var key in keys) {\n            if (keys.hasOwnProperty(key)) {\n\n                if (input.keyDown(key)) {\n\n                    if (!input.processedKey(key)) {\n                        input.handleKey(key, true);\n\n                        keys[key] = true;\n                        keyPressed = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return keyPressed;\n    }\n    return false;\n}\n\nfunction update(delta, moveCompleteCallback) {\n\n    var vect;\n    switch (player.getState()) {\n\n        case player.states.INPUT:\n\n            if (keys.left) {\n\n                player.direction -= (Math.PI * 2);\n                turnTo = {\n                    from: player.direction,\n                    to: (player.direction + (Math.PI / 2)) % (2 * Math.PI),\n                    dir: -1\n                };\n\n            } else if (keys.right) {\n                player.direction += (Math.PI * 2);  // so that our calculations for delta etc still work\n                turnTo = {\n                    from: player.direction,\n                    to: (player.direction - (Math.PI / 2)) % (2 * Math.PI),\n                    dir: 1\n                };\n\n            } else if (keys.up) {\n\n                vect = {\n                    x: Math.round(Math.sin(player.direction % (2 * Math.PI))) * -1,\n                    y: Math.round(Math.cos(player.direction % (2 * Math.PI))) * -1\n                };\n\n                walkTo = {\n                    from: {x: player.position.x, y: player.position.y},\n                    to: {x: player.position.x + vect.x, y: player.position.y + vect.y},\n                    dir: vect\n                };\n\n\n            } else if (keys.down) {\n\n                vect = {\n                    x: Math.round(Math.sin(player.direction % (2 * Math.PI))),\n                    y: Math.round(Math.cos(player.direction % (2 * Math.PI)))\n                };\n\n                walkTo = {\n                    from: {x: player.position.x, y: player.position.y},\n                    to: {x: player.position.x + vect.x, y: player.position.y + vect.y},\n                    dir: vect\n                };\n\n            }\n\n            if (turnTo.from !== turnTo.to) {\n                sounds.playSound('MOVE');\n                player.setState(player.states.TURNING);\n\n            } else if (walkTo.from !== walkTo.to) {\n\n                if (activeMap.canMove(walkTo.dir.x, walkTo.dir.y)) {\n                    sounds.playSound('MOVE');\n                    player.setState(player.states.MOVING);\n\n                } else {\n\n                    sounds.playSound('NO_MOVE');\n                    walkTo = {from: 0, to: 0, dir: 0};\n\n                    // we can't move here, maybe do an action\n                    moveCompleteCallback(false);\n                }\n\n            }\n\n            break;\n\n        case player.states.TURNING:\n\n            player.direction -= (delta * (turnTo.dir) * 3);\n            player.direction = player.direction % (Math.PI * 2);\n\n            if (reachedDestination(turnTo.from, turnTo.to, player.direction)) {\n\n                input.handleKey('left', false);\n                input.handleKey('right', false);\n\n                player.setState(player.states.INPUT);\n                player.direction = turnTo.to;\n                turnTo = {from: 0, to: 0, dir: 0};\n            }\n\n            break;\n\n        case player.states.MOVING:\n\n            player.position.x += (delta * 2 * walkTo.dir.x);\n            player.position.y += (delta * 2 * walkTo.dir.y);\n\n            var reachedX = reachedDestination(walkTo.from.x, walkTo.to.x, player.position.x);\n            var reachedY = reachedDestination(walkTo.from.y, walkTo.to.y, player.position.y);\n\n            if (reachedX && reachedY) {\n\n                input.handleKey('up', false);\n                input.handleKey('down', false);\n\n                player.setState(player.states.INPUT);\n                player.position.x = walkTo.to.x;\n                player.position.y = walkTo.to.y;\n                walkTo = {from: 0, to: 0, dir: 0};\n\n                // we moved somewhere so maybe take an action\n                moveCompleteCallback(true);\n            }\n\n            break;\n    }\n}\n\n\nfunction reachedDestination(from, to, current) {\n\n    if (from < to) {\n\n        if (current >= to) {\n            return true;\n        }\n\n    } else if (from > to) {\n\n        if (current <= to) {\n            return true;\n        }\n\n    } else {\n        return true;\n    }\n\n    return false;\n}","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar text = require('../text');\nvar images = require('../images');\nvar gameState = require('../gameState');\nvar textures = require('../textures');\nvar renderer = require('../renderer');\n\n\nmodule.exports = {\n    update: update,\n    render: render\n};\n\n\n/////////////////\n\n\nfunction render() {\n    text.drawText('Loading...' + images.loadPct(), 100, 100);\n}\n\n\nfunction update(delta) {\n    if (text.loaded && images.isLoaded() && textures.loadTextures()) {\n        renderer.initializeMap();\n        gameState.setNextState(gameState.states.DUNGEON);\n    }\n}","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar sounds = {\n    MOVE: loadSound('walking', 0.5),\n    NO_MOVE: loadSound('nomove'),\n    START_BATTLE: loadSound('startbattle2'),\n    MENU_MOVE: loadSound('menuitem', 0.4),\n    MENU_SELECT: loadSound('Pickup_Coin6'),\n    RUN: loadSound('battle_run2'),\n    NO_RUN: loadSound('menu_select')\n};\n\n\nmodule.exports = {\n    fx: sounds,\n    playSound: playSound\n};\n\n\n/////////////////////////////\n\nfunction loaded() {\n\n}\n\nfunction loadSound(sound, volume) {\n    //var snd = new Audio('/sounds/' + sound + '.wav');\n    //snd.volume = volume || 1.0;\n    //return snd;\n    var elem = document.createElement('audio');\n    elem.src = '/sounds/' + sound + '.wav';\n    elem.volume = volume || 1.0;\n    return elem;\n}\n\n\nfunction playSound(sound) {\n    try {\n        sounds[sound].currentTime = 0;\n        sounds[sound].play();\n    }\n    catch (err) {\n        // do something when sound doesn't play?\n        console.log(err);\n    }\n}\n\n\nfunction onLoad() {\n\n}","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\n\nvar textExport = {\n    drawCentered: drawCentered,\n    drawText: drawText,\n    loaded: false,\n    setCursor: setCursor,\n    textWidth: textWidth\n};\n\nmodule.exports = textExport;\n\n\nvar canvas = require('./canvas'),\n    changeColor = require('./changeColor'),\n    config = require('./config'),\n    utils = require('./utils');\n\n\nvar ctx = canvas.context;\n\nvar dataLoaded = false,\n    imageLoaded = false,\n    lineHeight = 0,\n    data = null,\n    fontName = 'roses',\n    fontImg = new Image(),\n    fontCache = {},\n    fontColors = {\n        'default': fontImg,\n        'red': new Image(),\n        'green': new Image()\n    };\n\n\n/**\n * The position where the text will be drawn\n * @type {{x: number, y: number}}\n */\nvar cursor = {x: 0, y: 0};\n\n\nloadFontImage(fontImg);\nloadFont();\n\n\n////////////////////////////////////////////////\n\n\n/**\n * Draws the glyph indicated by the code.\n * @param code\n * @returns {Number} The number of pixels to advance in the x-direction.\n * @param color\n */\nfunction drawGlyph(code, color) {\n    if (!textExport.loaded) return 0;\n\n    color = color || 'default';\n\n    var character = fontCache[code].char;\n\n    var dst = utils.scaleRect({\n        x: cursor.x + character.xoffset,\n        y: cursor.y + character.yoffset,\n        w: character.width,\n        h: character.height\n    }, config.scale);\n\n\n    if (character.width && character.height) {\n        var src = {x: character.x, y: character.y, w: character.width, h: character.height};\n        ctx.drawImage(fontColors[color], src.x, src.y, src.w, src.h, dst.x, dst.y, dst.w, dst.h);\n    }\n    return character.xadvance; // to advance the cursor\n}\n\n\n/**\n * Draws a string of text at the given coordinates.\n * @param text\n * @param x\n * @param y\n * @param color\n */\nfunction drawText(text, x, y, color) {\n    x = Math.round(x);\n    y = Math.round(y);\n    color = color || 'default';\n\n    setCursor(x, y);\n\n    text = text || '';\n    for (var i = 0; i < text.length; i++) {\n        var code = text.charCodeAt(i);\n        cursor.x += drawGlyph(code, color);\n    }\n}\n\n\nfunction drawCentered(text, y, color) {\n    if (!textExport.loaded) return;\n\n    var tw = textWidth(text);\n    var x = Math.floor((config.width / 2) - (tw / 2));\n    drawText(text, x, y, color || 'red');\n}\n\n\nfunction loadFontImage(fontImg) {\n    fontImg.src = \"/fontImage/\" + fontName;\n    fontImg.onload = function () {\n\n        // original font color: 240, 221, 178: #F0DDB2\n        // 252 234 199\n\n        /*  assign color changes here */\n        fontColors.red.src = changeColor(fontImg, {r: 200, g: 50, b: 50});//, {r: 252, g: 234, b: 199});\n        fontColors.green.src = changeColor(fontImg, {r: 50, g: 200, b: 50});//, {r: 252, g: 234, b: 199});\n\n        imageLoaded = true;\n        textExport.loaded = imageLoaded && dataLoaded;\n        console.log(textExport.loaded);\n    };\n}\n\n\nfunction loadFont() {\n    var oReq = new XMLHttpRequest();\n    oReq.onload = function () {\n        data = JSON.parse(this.responseText);\n\n        lineHeight = data.common.lineHeight;\n\n        for (var i = 0; i < data.chars.length; i++) {\n            fontCache[data.chars[i].id] = {\n                char: data.chars[i],\n                kerning: {}\n            };\n        }\n        for (var j = 0; j < data.kernings.length; j++) {\n            var kern = data.kernings[j];\n            var char = fontCache[kern.first];\n            if (char) {\n                char.kerning[kern.second] = kern.amount;\n            } else {\n                console.log(kern.first);\n            }\n        }\n\n        dataLoaded = true;\n        textExport.loaded = imageLoaded && dataLoaded;\n        console.log(textExport.loaded);\n    };\n    oReq.open(\"get\", \"/font/\" + fontName, true);\n    oReq.send();\n}\n\n\n/**\n * Moves the cursor to the indicated position.\n * @param x\n * @param y\n */\nfunction setCursor(x, y) {\n    cursor.x = x || 0;\n    cursor.y = y || 0;\n}\n\n\nfunction textWidth(text) {\n    if (!textExport.loaded) {\n        console.log(\"text not loaded...\");\n        return;\n    }\n    var width = 0;\n    text = text || '';\n    for (var i = 0; i < text.length; i++) {\n        var char = fontCache[text.charCodeAt(i)].char;\n        width += char.xadvance;\n    }\n    return width;\n}\n","/**\n * Created by john on 3/25/15.\n */\n\n'use strict';\n\n\nmodule.exports = {\n    loadTextures: loadTextures,\n    getTexture: function (key) {\n        return textures[key];\n    }\n};\n\n\nvar textureCount = 0;\nvar textures = {\n    wall: THREE.ImageUtils.loadTexture('/images/walltexture.png', {}, onLoad),\n    floor: THREE.ImageUtils.loadTexture('/images/floortexture.png', {}, onLoad)\n};\n\n\n/**\n * Allows preloading of all textures before we start rendering anything\n * @returns {boolean} True when all textures have been loaded.\n */\nfunction loadTextures() {\n    return (textureCount === Object.keys(textures).length);\n}\n\n\nfunction onLoad() {\n    textureCount++;\n}","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\n\nmodule.exports = {\n    clamp: clamp,\n    directionToVector: directionToVector,\n    distance: distance,\n    extend: extend,\n    isBetween: isBetween,\n    isWithin: isWithin,\n    randomBetween: randomBetween,\n    scaleRect: scaleRect\n};\n\n\nfunction clamp(value, min, max) {\n    return Math.min(max, Math.max(min, value));\n}\n\n\nfunction directionToVector(direction) {\n    var vect = {\n        x: Math.round(Math.sin(direction % (2 * Math.PI))),\n        y: Math.round(Math.cos(direction % (2 * Math.PI)))\n    };\n    return vect;\n}\n\n\nfunction distance(p1, p2) {\n    return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);\n}\n\n\nfunction extend() {\n    var defaults = arguments[0];\n    var options = arguments[1];\n\n    var extended = {};\n    if (arguments[2]) {\n        extended = defaults;\n    }\n\n    var prop;\n    for (prop in defaults) {\n        if (Object.prototype.hasOwnProperty.call(defaults, prop)) {\n            extended[prop] = defaults[prop];\n        }\n    }\n    for (prop in options) {\n        if (Object.prototype.hasOwnProperty.call(options, prop)) {\n            extended[prop] = options[prop];\n        }\n    }\n    return extended;\n}\n\n\nfunction isBetween(value, min, max) {\n    return value >= min && value < max;\n}\n\n\nfunction isWithin(point, rect) {\n    var x = isBetween(point.x, rect.x, rect.x + rect.w);\n    var y = isBetween(point.y, rect.y, rect.y + rect.h);\n    return x && y;\n\n}\n\n\nfunction scaleRect(rect, scale) {\n    return {\n        x: (rect.x * scale),\n        y: (rect.y * scale),\n        w: Math.floor(rect.w * scale),\n        h: (rect.h * scale)\n    };\n}\n\n\nfunction randomBetween(min, max) {\n    return Math.round(Math.random() * (max - min)) + min;\n}\n\n"]}