{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/client/main.js","src/client/activeMap.js","src/client/canvas.js","src/client/changeColor.js","src/client/config.js","src/client/gameLoop.js","src/client/gameState.js","src/client/images.js","src/client/input.js","src/client/map/atlas.js","src/client/map/mapGeometry.js","src/client/player.js","src/client/renderer.js","src/client/screens/dungeon/index.js","src/client/screens/dungeon/movement.js","src/client/screens/loading.js","src/client/sounds.js","src/client/text.js","src/client/utils.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"0.0.0.dungeoncrawler.min.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nrequire('./text');  // load text etc\n\nvar lastTime;\n\nwindow.onload = function () {\n\n    var w = window;\n    var requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;\n\n    var config = require('./config');\n    var input = require('./input');\n    var gameLoop = require('./gameLoop');\n    var canvas = require('./canvas');\n    var renderer = require('./renderer');\n\n\n    function main() {\n        var now = Date.now();\n        var delta = now - lastTime;\n\n        gameLoop.update(delta / 1000);\n        gameLoop.render();\n\n        lastTime = now;\n\n        // Request to do this again ASAP\n        requestAnimationFrame(main);\n    }\n\n    renderer.initialize();\n    document.body.appendChild(renderer.getElement());\n\n    if (window.addEventListener) {\n        //window.addEventListener('resize', canvas.resizeCanvas, false);\n        window.addEventListener('orientationchange', canvas.resizeCanvas, false);\n    }\n    input.registerEventHandlers();\n\n    lastTime = Date.now();\n\n    //canvas.resizeCanvas();\n    main();\n};","/**\n * Created by john on 3/22/15.\n */\n\nvar activeMap = module.exports = {};\n\n\nvar atlas = require('./map/atlas');\nvar player = require('./player');\n\n\nactiveMap.canMove = function canMove(dx, dy) {\n    var map = atlas.maps[player.currentMap];\n\n    var xc = player.position.x + dx;\n    var yc = player.position.y + dy;\n\n    return map.data[yc][xc] === 0;\n};","/**\n * Created by john on 3/22/15.\n *\n * This module gives access to the HUD canvas for drawing status, character info, etc on top of the WebGL\n * Three.js renderer.\n *\n * Because Three.js will map this onto a plane geometry the size of the screen, there's no need for double\n * buffering to rescale the pixel art, etc.\n */\n\n'use strict';\n\n\nvar config = require('./config');\n\n\n//var bgCanvas = createNewCanvas(config.width, config.height);\n//var bgCtx = bgCanvas.getContext(\"2d\");\n\nvar canvas = createNewCanvas(config.width, config.height);\nvar ctx = canvas.getContext(\"2d\");\n\n\nmodule.exports = {\n    clear: clear,\n    //context: bgCtx,\n    context: ctx,\n    createNewCanvas: createNewCanvas,\n    draw: draw,\n    element: canvas,\n    redraw: true,\n    resizeCanvas: resizeCanvas\n};\n\n///////////////////////////////\n\nfunction clear() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    //bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);\n}\n\n\nfunction createNewCanvas(width, height) {\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\n\n\nfunction draw() {\n    var w = config.width;// * config.scale;\n    var h = config.height;// * config.scale;\n    //ctx.drawImage(bgCanvas, 0, 0, w, h);\n    ctx.drawImage(canvas, 0, 0, w, h);\n}\n\n\n// shamelessly ripped from heroine dusk code\nfunction resizeCanvas() {\n    var aspect_ratio = 4 / 3;\n\n    var h, w;\n\n    // the screen is wider than 4:3\n    if (window.innerWidth * (3 / 4) > window.innerHeight) {\n        h = window.innerHeight;\n        w = h * aspect_ratio;\n        config.scale = h / config.height;\n    }\n    // the screen is taller than 4:3\n    else {\n        w = window.innerWidth;\n        h = w / aspect_ratio;\n        config.scale = w / config.width;\n    }\n\n    config.scale = Math.floor(config.scale);\n    //canvas.height = h;\n    //canvas.width = w;\n    canvas.height = config.height * config.scale;\n    canvas.width = config.width * config.scale;\n\n    module.exports.redraw = true;\n    setNearestNeighbor();\n}\n\n\nfunction setNearestNeighbor() {\n    ctx.imageSmoothingEnabled = false;\n    ctx.webkitImageSmoothingEnabled = false;\n    ctx.mozImageSmoothingEnabled = false;\n    ctx.oImageSmoothingEnabled = false;\n}\n","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar canvas = require('./canvas');\n\n\n/**\n * @description         Examines each pixel in the given image and changes all oldColor pixels to newColor, or if oldColor\n *                      is not specified then changes all non-black pixels to newColor\n * @param img\n * @param newColor      {Object} - {r, g, b}\n * @param oldColor      {Object} - {r, g, b}\n * @returns {String}    A DataURL that can be used as a .src for an Image\n */\nfunction changeColor(img, newColor, oldColor) {\n    newColor = newColor || {};\n    oldColor = oldColor || {};\n\n    var cnv = canvas.createNewCanvas(img.width, img.height);\n    var ctx = cnv.getContext('2d');\n\n    var nR = newColor.r || 0,\n        nG = newColor.g || 0,\n        nB = newColor.b || 0;\n\n    var oR = oldColor.r,\n        oG = oldColor.g,\n        oB = oldColor.b;\n\n    ctx.drawImage(img, 0, 0);\n\n    // pull the entire image into an array of pixel data\n    var imageData = ctx.getImageData(0, 0, img.width, img.height);\n\n    // examine every pixel,\n    // change any old rgb to the new-rgb\n    for (var i = 0; i < imageData.data.length; i += 4) {\n        if ((imageData.data[i] == oR &&\n            imageData.data[i + 1] == oG &&\n            imageData.data[i + 2] == oB\n            ) || ((!oR && !oG && !oB) && imageData.data[i] > 0)) {\n\n            imageData.data[i] = nR;\n            imageData.data[i + 1] = nG;\n            imageData.data[i + 2] = nB;\n        }\n    }\n    // put the altered data back on the canvas\n    ctx.putImageData(imageData, 0, 0);\n    return cnv.toDataURL();\n}\n\nmodule.exports = changeColor;","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\nvar scaleFactor = 2;\n\nvar config = {\n    fps: 60,\n    scale: 1,\n    width: 160 * scaleFactor,\n    height: 120 * scaleFactor\n};\n\nmodule.exports = config;\n","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\nvar gameState = require('./gameState');\nvar canvas = require('./canvas');\nvar renderer = require('./renderer');\n\nvar screens = {\n    loading: require('./screens/loading'),\n    //title: require('./screens/title'),\n    //town: require('./screens/town'),\n    dungeon: require('./screens/dungeon')\n};\n\nvar states = gameState.states;\n\n\nmodule.exports = {\n    update: update,\n    render: render\n};\n\n////////////////////////////////\n\nfunction update(delta) {\n    renderer.update(delta);\n\n    switch (gameState.currentState) {\n\n        case states.LOADING:\n            screens.loading.update(delta);\n            break;\n\n        //case states.TITLE:\n        //    screens.title.update(delta);\n        //    break;\n        //\n        //case states.TOWN:\n        //    screens.town.update(delta);\n        //    break;\n\n        case states.DUNGEON:\n            screens.dungeon.update(delta);\n            break;\n    }\n}\n\n\nfunction render() {\n    renderer.render();\n\n\n    if (!canvas.redraw) return;\n    canvas.clear();\n\n    switch (gameState.currentState) {\n\n        case states.LOADING:\n            screens.loading.render();\n            break;\n\n        //case states.TITLE:\n        //    screens.title.render();\n        //    break;\n        //\n        //case states.TOWN:\n        //    screens.town.render();\n        //    break;\n\n        case states.DUNGEON:\n            screens.dungeon.render();\n            break;\n\n    }\n    canvas.draw();\n    canvas.redraw = false;\n}","/**\n * Created by john on 3/22/15.\n */\n\n\n\n'use strict';\n\nvar canvas = require('./canvas');\nvar ctx = canvas.context;\n\nvar states = {\n    LOADING: \"loading\",\n    TITLE: \"title\",\n    TOWN: \"town\",\n    DUNGEON: \"dungeon\",\n    BATTLE: \"battle\"\n};\n\n\nvar gameState = {\n    currentState: states.LOADING,\n    setNextState: setNextState,\n    states: states\n};\n\n\nmodule.exports = gameState;\n\n//////////////////////////\n\n\nfunction setNextState(state) {\n    ctx.globalAlpha = 1;\n    canvas.redraw = true;\n    gameState.currentState = state;\n}","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar canvas = require('./canvas');\nvar ctx = canvas.context;\n\nvar totalImages = 9999;\nvar loadedImages = 0;\nvar loaded = false;\n\nvar images = {};\n\n\nimages.wallTexture = loadImage('walltexture');\nimages.floorTexture = loadImage('floortexture');\n\n//images.title = loadImage('title');\n//\n//images.borderUL = loadImage('textborder', {x: 0, y: 0, w: 16, h: 16});\n//images.borderU = loadImage('textborder', {x: 16, y: 0, w: 16, h: 16});\n//images.borderUR = loadImage('textborder', {x: 32, y: 0, w: 16, h: 16});\n//images.borderL = loadImage('textborder', {x: 0, y: 16, w: 16, h: 16});\n//images.borderM = loadImage('textborder', {x: 16, y: 16, w: 16, h: 16});\n//images.borderR = loadImage('textborder', {x: 32, y: 16, w: 16, h: 16});\n//images.borderBL = loadImage('textborder', {x: 0, y: 32, w: 16, h: 16});\n//images.borderB = loadImage('textborder', {x: 16, y: 32, w: 16, h: 16});\n//images.borderBR = loadImage('textborder', {x: 32, y: 32, w: 16, h: 16});\n//\n//images.room = loadImage('mapTiles', {x: 16, y: 0, w: 16, h: 16});\n//images.visitedroom = loadImage('mapTiles', {x: 0, y: 0, w: 16, h: 16});\n//images.currentPos = loadImage('mapTiles', {x: 22, y: 22, w: 4, h: 4});\n//\n//images.hCorridor = loadImage('mapTiles', {x: 32, y: 6, w: 4, h: 4});    // real width=16\n//images.vCorridor = loadImage('mapTiles', {x: 6, y: 16, w: 4, h: 4});    // real height=16\n//\n//images.stairsUp = loadImage('mapTiles', {x: 32, y: 16, w: 16, h: 16});\n//\n//images.skull = loadImage('skull', {x: 0, y: 0, w: 50, h: 50});\n//\n//\n//images.tilesets = {};   // indexed by distance from player, 0=closest (tiles1), 4=furthest (tiles5)\n//images.tilesets.dungeon = [\n//    {\n//        l: loadImage('tiles1', {x: 0, y: 0, w: 25, h: 140}),\n//        r: loadImage('tiles1', {x: 175, y: 0, w: 25, h: 140}),\n//        floor: loadImage('floors', {x: 0, y: 53, w: 200, h: 17}),\n//        wall_l: loadImage('tiles1', {x: 175, y: 17, w: 25, h: 106}),\n//        wall_r: loadImage('tiles1', {x: 0, y: 17, w: 25, h: 106}),     // fix this, create actual wall graphics\n//        wall: loadImage('tiles1', {x: 25, y: 17, w: 150, h: 106})\n//    }\n//];\n\n\n// get total number of images to make sure we've loaded everything\ntotalImages = Object.keys(images).length;\nif (checkLoadComplete()) loaded = true;\n\nmodule.exports = {\n    drawBorder: drawBorder,\n    drawImage: drawImage,\n    getBorder: getBorder,\n    images: images,\n    isLoaded: function () {\n        return loaded;\n    },\n    loadPct: function () {\n        return loadedImages / totalImages;\n    }\n};\n\n////////////////////////////////////////\n\n\nfunction onLoad() {\n    loadedImages++;\n    if (checkLoadComplete()) {\n        loaded = true;\n    }\n}\n\nfunction checkLoadComplete() {\n    return loadedImages >= totalImages;\n}\n\n\nfunction drawBorder(rect) {\n    if (!loaded) return;\n    var x = rect.x,\n        y = rect.y,\n        w = rect.w,\n        h = rect.h;\n\n    var borderSize = 16;\n\n    var bottomRow = (y + h) - borderSize;\n    var rightCol = (x + w) - borderSize;\n\n    // take advantage of the fact that the border graphics are one color so we can stretch them\n\n    drawImage('borderM', rect.x, rect.y, rect.w, rect.h);\n    drawImage('borderU', rect.x, rect.y, rect.w, borderSize);\n    drawImage('borderL', rect.x, rect.y, borderSize, rect.h);\n    drawImage('borderR', rect.w - borderSize, rect.y, borderSize, rect.h);\n    drawImage('borderB', rect.x, rect.h - borderSize, rect.w, borderSize);\n\n    drawImage('borderUL', x, y);\n    drawImage('borderUR', rightCol, y);\n    drawImage('borderBL', x, bottomRow);\n    drawImage('borderBR', rightCol, bottomRow);\n}\n\n\nfunction drawImage(image, x, y, w, h) {\n    if (!loaded) return;\n\n    var img = typeof(image) === 'object' ? image : images[image];\n    w = w || img.sw;\n    h = h || img.sh;\n\n\n    if (img.sx !== undefined && img.sy !== undefined) {\n        ctx.drawImage(img, img.sx, img.sy, img.sw, img.sh, x, y, w, h);\n    } else {\n        ctx.drawImage(img, x, y);\n    }\n}\n\n\nfunction getBorder(rect) {\n    var config = require('./config');\n\n    console.log('getBorder');\n    console.log(rect);\n\n    var cnv = canvas.createNewCanvas(config.width, config.height);\n    var context = cnv.getContext(\"2d\");\n\n    // switch the context around and draw to the new canvas, then switch it back\n    ctx = context;\n    var r2 = {x: 0, y: 0, w: rect.w, h: rect.h};\n    drawBorder(r2);\n    ctx = canvas.context;\n    return cnv;\n}\n\n\nfunction loadImage(image, src) {\n    var img = new Image();\n    img.onload = onLoad;\n    img.src = '/images/' + image + '.png';\n    if (src) {\n        img.sx = src.x;\n        img.sy = src.y;\n        img.sw = src.w;\n        img.sh = src.h;\n    }\n    return img;\n}\n\n\n","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\nmodule.exports = {\n    //clickPos: clickPos,\n    //getMouseClick: getMouseClick,\n    //isClicked: isClicked,\n    //isMouseOver: isMouseOver,\n\n    keyDown: isKeyDown,\n    handleKey: function (key, processed) {\n        processedKey[key] = processed;\n    },\n\n    //mousePos: mousePos,\n    //mousePressed: mousePressed,\n\n    processedKey: isKeyHandled,\n    registerEventHandlers: registerEventHandlers\n};\n\n\nvar config = require('./config');\nvar canvas = require('./canvas').element;\nvar utils = require('./utils');\n\n\nvar KEYCODE = {\n    //UP: 38,\n    //DOWN: 40,\n    //LEFT: 37,\n    //RIGHT: 39,\n    UP: 87,\n    DOWN: 83,\n    LEFT: 65,\n    RIGHT: 68,\n    SPACE: 32\n};\n/*\n\n if (keyCode == 87) {\n camera.translateZ(-200);\n }\n if (keyCode == 68) {\n camera.rotation.y -= (Math.PI / 2);\n }\n if (keyCode == 83) {\n camera.translateZ(200);\n }\n if (keyCode == 65) {\n camera.rotation.y += (Math.PI / 2);\n }\n\n */\n\nvar mousePressed = {\n    left: false,\n    right: false\n};\n\nvar keyDown = {\n    left: false,\n    right: false,\n    up: false,\n    down: false\n};\n\nvar preventInput = {\n    left: false,\n    right: false\n};\n\nvar processedKey = {\n    left: false,\n    right: false,\n    up: false,\n    down: false,\n    action: false\n};\n\n\nvar mousePos = {x: 0, y: 0};\nvar clickPos = null;\n\n\nfunction handleMouseDown(evt) {\n    evt.preventDefault();\n    mousePressed.left = true;\n    clickPos = clickCoord(evt);\n}\n\nfunction handleMouseUp(evt) {\n    mousePressed.left = false;\n    preventInput.left = false;\n    clickPos = null;\n}\n\nfunction handleMouseOver(evt) {\n    mousePos = clickCoord(evt);\n}\n\nfunction clickCoord(evt) {\n\n    var canx;\n    var cany;\n\n    if (evt.pageX || evt.pageY) {\n        canx = evt.pageX;\n        cany = evt.pageY;\n    }\n    else {\n        canx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n        cany = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n    }\n    canx -= canvas.offsetLeft;\n    cany -= canvas.offsetTop;\n\n    canx /= config.scale;\n    cany /= config.scale;\n\n    return {x: canx, y: cany};\n}\n\n/** Touch Handler **/\n\nfunction handleTouchStart(evt) {\n    evt.preventDefault();\n    mousePressed.left = true;\n    mousePos = touchCoord(evt);\n}\n\n\nfunction handleTouchEnd(evt) {\n    mousePressed.left = false;\n    preventInput.left = false;\n}\n\n\nfunction handleKeyDown(evt) {\n    function setKey(key) {\n        keyDown[key] = true;\n        evt.preventDefault();\n    }\n\n    if (evt.keyCode == KEYCODE.UP) {\n        //keyDown.up = true;\n        setKey('up');\n    }\n    else if (evt.keyCode == KEYCODE.DOWN) {\n        //keyDown.down = true;\n        setKey('down');\n    }\n    else if (evt.keyCode == KEYCODE.LEFT) {\n        //keyDown.left = true;\n        setKey('left');\n    }\n    else if (evt.keyCode == KEYCODE.RIGHT) {\n        //keyDown.right = true;\n        setKey('right');\n    }\n    else if (evt.keyCode == KEYCODE.SPACE) {\n        keyDown.action = true;\n    }\n}\n\n\nfunction handleKeyUp(evt) {\n    if (evt.keyCode == KEYCODE.UP) {\n        keyDown.up = false;\n        processedKey.up = false;\n    }\n    else if (evt.keyCode == KEYCODE.DOWN) {\n        keyDown.down = false;\n        processedKey.down = false;\n    }\n    else if (evt.keyCode == KEYCODE.LEFT) {\n        keyDown.left = false;\n        processedKey.left = false;\n    }\n    else if (evt.keyCode == KEYCODE.RIGHT) {\n        keyDown.right = false;\n        processedKey.right = false;\n    }\n    else if (evt.keyCode == KEYCODE.SPACE) {\n        keyDown.action = false;\n        processedKey.action = false;\n    }\n}\n\n\nfunction registerEventHandlers() {\n    if (window.addEventListener) {\n        window.addEventListener('keydown', handleKeyDown, true);\n        window.addEventListener('keyup', handleKeyUp, true);\n        window.addEventListener('mousedown', handleMouseDown, true);\n        window.addEventListener('mouseup', handleMouseUp, true);\n        window.addEventListener('mousemove', handleMouseOver, true);\n        window.addEventListener('touchstart', handleTouchStart, true);\n        window.addEventListener('touchend', handleTouchEnd, true);\n    }\n}\n\n\n/**\n * Returns true if the mouse is down within the specified rectangle\n * @param rect\n */\nfunction isClicked(rect) {\n    if (!rect) return false;\n    if (preventInput.left) {\n        console.log(\"preventinput\");\n        return false;\n    }\n\n    var clicked = mousePressed.left && isMouseOver(rect);\n    if (clicked) {\n        // make sure we don't process 2 clicks in 2 subsequent frames if the button is held down\n        mousePressed.left = false;\n    }\n    return clicked;\n}\n\n\nfunction getMouseClick() {\n    if (preventInput.left) return false;\n\n    var clicked = mousePressed.left;\n    if (clicked) {\n        mousePressed.left = false;\n        return clickPos;\n    }\n    return null;\n}\n\n\nfunction touchCoord(evt) {\n    var canx = evt.touches[0].pageX;\n    var cany = evt.touches[0].pageY;\n\n    canx -= canvas.offsetLeft;\n    cany -= canvas.offsetTop;\n\n    canx /= config.scale;\n    cany /= config.scale;\n\n    return {x: canx, y: cany};\n}\n\n\nfunction isMouseOver(rect) {\n    if (!rect) return false;\n    return utils.isWithin(mousePos, rect);\n}\n\nfunction isKeyDown(key) {\n    return keyDown[key];\n}\n\nfunction isKeyHandled(key) {\n    return processedKey[key];\n}\n\n","/**\n * Created by john on 3/22/15.\n */\n\nvar atlas = module.exports = {};\n\n\nvar map2 = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1],\n    [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1],\n    [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n    [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1],\n    [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1],\n    [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],\n    [1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1],\n    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],\n    [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n];\n\n\nvar maps = [\n    {\n        name: 'Starting map',\n        data: map2,\n        //rooms: initialize(map),\n        ////startRoom: {x: 2, y: 2},\n        startRoom: {x: 0, y: 3},\n        maxEncounterChance: 0.6\n    }\n];\n\n\natlas.maps = maps;\n","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar textureCount = 0;\nvar textures = {\n    wall: THREE.ImageUtils.loadTexture('/images/walltexture.png', {}, function () {\n        textureCount++;\n    }),\n    floor: THREE.ImageUtils.loadTexture('/images/floortexture.png', {}, function () {\n        textureCount++;\n    })\n};\n\nmodule.exports = {\n    loadTextures: loadTextures,\n    getMapGeometry: getMapGeometry,\n    getMapMesh: getMapMesh\n};\n\n\nfunction loadTextures() {\n    return (textureCount === Object.keys(textures).length);\n}\n\n\nfunction transx(geo, n) {\n    for (var i = 0; i < geo.vertices.length; i++) {\n        geo.vertices[i].x += n;\n    }\n}\n\n/**\n * Translate all points in a geometry `n` units in the z direction.\n */\nfunction transz(geo, n) {\n    for (var i = 0; i < geo.vertices.length; i++) {\n        geo.vertices[i].z += n;\n    }\n}\n\n\nfunction getMapGeometry(map) {\n    return {\n        mesh: getMapMesh(map),\n        floor: getFloor(map)\n    };\n}\n\nfunction getMapMesh(map) {\n    var geometry, material, mesh;\n    var img = textures.wall;\n    img.minFilter = THREE.NearestFilter;\n    img.magFilter = THREE.NearestFilter;\n\n\n    geometry = new THREE.BoxGeometry(200, 200, 200);\n    material = new THREE.MeshLambertMaterial({color: 0xaabbaa, wireframe: false, map: img});\n\n\n    for (var j = 0; j < map.length; j++) {\n        for (var i = 0; i < map[j].length; i++) {\n\n            if (map[j][i] === 1) {\n                var tmp = new THREE.BoxGeometry(200, 200, 200);\n                transx(tmp, i * 200);\n                transz(tmp, j * 200);\n                console.log('i=' + i + ', j=' + j);\n\n                geometry.merge(tmp);\n            }\n\n        }\n    }\n\n    mesh = new THREE.Mesh(geometry, material);\n    return mesh;\n}\n\n\nfunction getFloor(map) {\n\n    var width = map[0].length;\n    var height = map.length;\n    var cellSize = 200;\n\n    var texture = textures.floor;\n    texture.minFilter = THREE.NearestFilter;\n    texture.magFilter = THREE.NearestFilter;\n\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n\n    //texture.repeat.set(width * 3, height * 3);\n    texture.repeat.set(25 ,25);\n    texture.needsUpdate = true;\n    var material = new THREE.MeshPhongMaterial({map: texture, doubleSided: true, side: THREE.DoubleSide});\n\n    var geometryPlane = new THREE.PlaneBufferGeometry(width * 3 * cellSize, height * 3 * cellSize);\n    var plane = new THREE.Mesh(geometryPlane, material);\n\n    //plane.rotation.x = -Math.PI / 2;\n    plane.position.y = -100;    // center is at 0, height is 200\n    plane.position.x = 0;\n    plane.position.z = 0;\n\n    var plane2geom = new THREE.PlaneBufferGeometry(200*25, 200*25);\n    //var plane2geom = new THREE.PlaneBufferGeometry(width * 1 * cellSize, height * 1 * cellSize);\n    var material2 = new THREE.MeshPhongMaterial({map: texture, doubleSided: true, side: THREE.DoubleSide});\n    var plane2 = new THREE.Mesh(plane2geom, material2);\n\n    plane2.rotation.x = -Math.PI / 2;\n    plane2.position.y = -100;\n    plane2.position.x = 600;\n    plane2.position.z = 800;\n\n\n    return plane2;\n}","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar player = module.exports = {\n    currentMap: 0,\n    direction: 0,\n    flags: []\n};\n\n\nvar states = {\n        MOVING: 0,\n        TURNING: 1,\n        INPUT: 2,\n        NO_MOVE: 3\n    },\n    currentState = states.INPUT;\n\n\nplayer.direction = Math.PI;\nplayer.hasFlag = hasFlag;\nplayer.position = {x: 3, y: 3};\nplayer.states = states;\n\nplayer.getState = function getState() {\n    return currentState;\n};\nplayer.setState = function setState(state) {\n    currentState = state;\n};\n\n\nfunction hasFlag(flag) {\n    return player.flags.indexOf(flag) >= 0;\n}\n","/**\n * Created by john on 3/22/15.\n *\n * This module renders the view using Three.js\n */\n\n'use strict';\n\nvar viewRenderer = module.exports = {\n    'getElement': function () {\n        return domElement;\n    },\n    'initialize': initialize,\n    'initializeMap': initializeMap,\n    'render': render,\n    'update': update\n};\n\n\nviewRenderer.updateHud = function updateHud() {\n    cnvText.needsUpdate = true;\n};\n\n\nvar atlas = require('./map/atlas'),\n    canvas = require('./canvas'),\n    config = require('./config'),\n    player = require('./player');\n\n\nvar cnvText;\n\n\nvar mapGeometry = require('./map/mapGeometry');\nvar hudMesh;\nvar scene, hudScene;\nvar camera, hudCam;\nvar renderer;\nvar domElement;\nvar playerLight;\n\nvar tileSize = 200,\n    WIDTH = config.width,\n    HEIGHT = config.height;\n\n\nfunction initialize() {\n\n    var scale = Math.floor(window.innerHeight / HEIGHT);    // scale to the available vertical space\n\n    var wWidth = WIDTH * scale,\n        wHeight = HEIGHT * scale,\n        aspect = wWidth / wHeight;\n\n    var context = canvas.context;\n\n    context.fillStyle = 'rgb(100,50,150)';\n    context.fillStyle = 'rgb(50, 50, 75)';\n    //context.fillRect(5, 180, 310, 60);\n\n    context.fillStyle = 'rgb(250, 50, 200)';\n    context.fillRect(3, 80, 1, 5);\n\n\n    cnvText = new THREE.Texture(canvas.element);\n    cnvText.needsUpdate = true;\n    cnvText.minFilter = THREE.NearestFilter;\n    cnvText.magFilter = THREE.NearestFilter;\n\n\n    scene = new THREE.Scene();\n    hudScene = new THREE.Scene();\n\n    camera = new THREE.PerspectiveCamera(80, aspect, 1, 10000);\n    camera.position.y = -20;\n\n    var width = wWidth;\n    var height = wHeight;\n\n    hudCam = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 10000);\n    hudCam.position.z = 100;\n\n    var planeGeom = new THREE.PlaneBufferGeometry(wWidth, wHeight);\n    var textMater = new THREE.MeshBasicMaterial({\n        map: cnvText,\n        color: 0xffffff,\n        transparent: true\n    });\n\n\n    hudMesh = new THREE.Mesh(planeGeom, textMater);\n    hudMesh.lookAt(hudCam.position); // Rotate the mesh so the face is fully visible by the camera\n    hudScene.add(hudMesh);\n\n    renderer = new THREE.WebGLRenderer({antialiasing: false});\n\n\n    renderer.setSize(wWidth, wHeight);\n    renderer.setClearColor(0x0088FF, 1);\n    renderer.autoClear = false;\n\n    domElement = renderer.domElement;\n}\n\nfunction initializeMap() {\n    var geometry = mapGeometry.getMapGeometry(atlas.maps[0].data);\n    var mesh = geometry.mesh;\n    var floor = geometry.floor;\n    scene.add(mesh);\n    scene.add(floor);\n\n\n    playerLight = new THREE.PointLight(0xaaaaaa);\n    playerLight.castShadow = false;\n    playerLight.shadowMapWidth = 128;\n    playerLight.shadowMapHeight = 128;\n    playerLight.shadowCameraNear = 1;\n    playerLight.shadowCameraFar = 100; //XXX: That should be far enough.\n    playerLight.shadowCameraFov = 90;\n    playerLight.shadowDarkness = 0.75; //XXX: Can change later...\n    playerLight.intensity = 2.5;\n    //playerLight.exponent = 20;\n    playerLight.angle = Math.PI / 3;\n    playerLight.distance = 200 * 10;\n\n    //scene.add(playerLight);\n\n    scene.add(camera);\n    camera.add(playerLight);\n\n    renderer.render(scene, camera);\n    renderer.render(hudScene, hudCam);\n\n}\n\n\nfunction update(delta) {\n    camera.rotation.y = player.direction;\n    camera.position.z = tileSize * player.position.y;   // z-coord: fwd/back\n    camera.position.x = tileSize * player.position.x;   // x-coord: left/right\n}\n\n\nfunction render() {\n\n    renderer.render(scene, camera);\n    renderer.render(hudScene, hudCam);\n}","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\nvar dungeon = module.exports = {};\n\nvar canvas = require('./../../canvas'),\n    input = require('./../../input'),\n    movement = require('./movement'),\n    renderer = require('./../../renderer'),\n    text = require('../../text');\n\n\n/**\n * @description     Updates each frame\n */\ndungeon.update = function update(delta) {\n    movement.processKeys();\n    movement.update(delta);\n};\n\n/**\n * @description     Renders the view\n */\ndungeon.render = function render() {\n\n    text.drawCentered('You are walking around in a maze.', 10);\n    renderer.updateHud();\n};","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar movement = module.exports = {};\n\nvar activeMap = require('../../activeMap'),\n    input = require('../../input'),\n    player = require('../../player'),\n    sounds = require('../../sounds'),\n    util = require('../../utils');\n\n\nvar keys = {left: false, right: false, up: false, down: false};\n\nvar turnTo = {\n        from: 0,\n        to: 0,\n        dir: 0\n    },\n    walkTo = {\n        from: 0,\n        to: 0,\n        dir: 0\n    };\n\n\nmovement.processKeys = processKeys;\nmovement.update = update;\n\n\nfunction processKeys() {\n\n    keys = {\n        left: false, right: false, up: false, down: false\n    };\n    if (player.getState() === player.states.INPUT) {\n        var keyPressed = false;\n        for (var key in keys) {\n            if (keys.hasOwnProperty(key)) {\n\n                if (input.keyDown(key)) {\n\n                    if (!input.processedKey(key)) {\n                        input.handleKey(key, true);\n\n                        keys[key] = true;\n                        keyPressed = true;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction update(delta) {\n\n    var vect;\n    switch (player.getState()) {\n\n        case player.states.INPUT:\n\n            if (keys.left) {\n\n                player.direction -= (Math.PI * 2);\n                turnTo = {\n                    from: player.direction,\n                    to: (player.direction + (Math.PI / 2)) % (2 * Math.PI),\n                    dir: -1\n                };\n\n            } else if (keys.right) {\n                player.direction += (Math.PI * 2);  // so that our calculations for delta etc still work\n                turnTo = {\n                    from: player.direction,\n                    to: (player.direction - (Math.PI / 2)) % (2 * Math.PI),\n                    dir: 1\n                };\n\n            } else if (keys.up) {\n\n                vect = {\n                    x: Math.round(Math.sin(player.direction % (2 * Math.PI))) * -1,\n                    y: Math.round(Math.cos(player.direction % (2 * Math.PI))) * -1\n                };\n\n                walkTo = {\n                    from: {x: player.position.x, y: player.position.y},\n                    to: {x: player.position.x + vect.x, y: player.position.y + vect.y},\n                    dir: vect\n                };\n\n\n            } else if (keys.down) {\n\n                vect = {\n                    x: Math.round(Math.sin(player.direction % (2 * Math.PI))),\n                    y: Math.round(Math.cos(player.direction % (2 * Math.PI)))\n                };\n\n                walkTo = {\n                    from: {x: player.position.x, y: player.position.y},\n                    to: {x: player.position.x + vect.x, y: player.position.y + vect.y},\n                    dir: vect\n                };\n\n            }\n\n            if (turnTo.from !== turnTo.to) {\n                sounds.playSound('MOVE');\n                player.setState(player.states.TURNING);\n\n            } else if (walkTo.from !== walkTo.to) {\n\n                if (activeMap.canMove(walkTo.dir.x, walkTo.dir.y)) {\n                    sounds.playSound('MOVE');\n                    player.setState(player.states.MOVING);\n\n                } else {\n\n                    sounds.playSound('NO_MOVE');\n                    walkTo = {from: 0, to: 0, dir: 0};\n                }\n\n            }\n\n            break;\n\n        case player.states.TURNING:\n\n            player.direction -= (delta * (turnTo.dir) * 3);\n            player.direction = player.direction % (Math.PI * 2);\n\n            if (reachedDestination(turnTo.from, turnTo.to, player.direction)) {\n\n                input.handleKey('left', false);\n                input.handleKey('right', false);\n\n                player.setState(player.states.INPUT);\n                player.direction = turnTo.to;\n                turnTo = {from: 0, to: 0, dir: 0};\n            }\n\n            break;\n\n        case player.states.MOVING:\n\n            player.position.x += (delta * 2 * walkTo.dir.x);\n            player.position.y += (delta * 2 * walkTo.dir.y);\n\n            var reachedX = reachedDestination(walkTo.from.x, walkTo.to.x, player.position.x);\n            var reachedY = reachedDestination(walkTo.from.y, walkTo.to.y, player.position.y);\n\n            if (reachedX && reachedY) {\n\n                input.handleKey('up', false);\n                input.handleKey('down', false);\n\n                player.setState(player.states.INPUT);\n                player.position.x = walkTo.to.x;\n                player.position.y = walkTo.to.y;\n                walkTo = {from: 0, to: 0, dir: 0};\n            }\n\n            break;\n    }\n}\n\n\nfunction reachedDestination(from, to, current) {\n\n    if (from < to) {\n\n        if (current >= to) {\n            return true;\n        }\n\n    } else if (from > to) {\n\n        if (current <= to) {\n            return true;\n        }\n\n    } else {\n        return true;\n    }\n\n    return false;\n}","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar text = require('../text');\nvar images = require('../images');\nvar gameState = require('../gameState');\nvar mapGeometry = require('../map/mapGeometry');\nvar renderer = require('../renderer');\n\n\nmodule.exports = {\n    update: update,\n    render: render\n};\n\n\n/////////////////\n\n\nfunction render() {\n    text.drawText('Loading...' + images.loadPct(), 100, 100);\n}\n\n\nfunction update(delta) {\n    if (text.loaded && images.isLoaded() && mapGeometry.loadTextures()) {\n        renderer.initializeMap();\n        gameState.setNextState(gameState.states.DUNGEON);\n    }\n}","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\nvar sounds = {\n    MOVE: loadSound('walking', 0.4),\n    NO_MOVE: loadSound('nomove'),\n    START_BATTLE: loadSound('startbattle2')\n};\n\n\nmodule.exports = {\n    fx: sounds,\n    playSound: playSound\n};\n\n\n/////////////////////////////\n\nfunction loadSound(sound, volume) {\n    var snd = new Audio('/sounds/' + sound + '.wav');\n    snd.volume = volume || 1.0;\n    return snd;\n}\n\n\nfunction playSound(sound) {\n    try {\n        sounds[sound].currentTime = 0;\n        sounds[sound].play();\n    }\n    catch (err) {\n        // do something when sound doesn't play?\n        console.log(err);\n    }\n}","/**\n * Created by john on 3/22/15.\n */\n\n'use strict';\n\n\nvar textExport = {\n    drawCentered: drawCentered,\n    drawText: drawText,\n    loaded: false,\n    setCursor: setCursor,\n    textWidth: textWidth\n};\n\nmodule.exports = textExport;\n\n\nvar canvas = require('./canvas'),\n    changeColor = require('./changeColor'),\n    config = require('./config'),\n    utils = require('./utils');\n\n\nvar ctx = canvas.context;\n\nvar dataLoaded = false,\n    imageLoaded = false,\n    lineHeight = 0,\n    data = null,\n    fontName = 'roses',\n    fontImg = new Image(),\n    fontCache = {},\n    fontColors = {\n        'default': fontImg,\n        'red': new Image(),\n        'green': new Image()\n    };\n\n\n/**\n * The position where the text will be drawn\n * @type {{x: number, y: number}}\n */\nvar cursor = {x: 0, y: 0};\n\n\nloadFontImage(fontImg);\nloadFont();\n\n\n////////////////////////////////////////////////\n\n\n/**\n * Draws the glyph indicated by the code.\n * @param code\n * @returns {Number} The number of pixels to advance in the x-direction.\n */\nfunction drawGlyph(code, color) {\n    if (!textExport.loaded) return 0;\n\n    color = color || 'default';\n\n    var character = fontCache[code].char;\n\n    var dst = utils.scaleRect({\n        x: cursor.x + character.xoffset,\n        y: cursor.y + character.yoffset,\n        w: character.width,\n        h: character.height\n    }, config.scale);\n\n    var src = {x: character.x, y: character.y, w: character.width, h: character.height};\n\n    ctx.drawImage(fontColors[color], src.x, src.y, src.w, src.h, dst.x, dst.y, dst.w, dst.h);\n\n    return character.xadvance; // to advance the cursor\n}\n\n\n/**\n * Draws a string of text at the given coordinates.\n * @param text\n * @param x\n * @param y\n */\nfunction drawText(text, x, y, color) {\n    x = Math.round(x);\n    y = Math.round(y);\n    color = color || 'default';\n\n    setCursor(x, y);\n\n    text = text || '';\n    for (var i = 0; i < text.length; i++) {\n        var code = text.charCodeAt(i);\n        cursor.x += drawGlyph(code, color);\n    }\n}\n\n\nfunction drawCentered(text, y) {\n    if (!textExport.loaded) return;\n\n    var tw = textWidth(text);\n    var x = Math.floor((config.width / 2) - (tw / 2));\n    drawText(text, x, y, 'red');\n}\n\n\nfunction loadFontImage(fontImg) {\n    fontImg.src = \"/fontImage/\" + fontName;\n    fontImg.onload = function () {\n\n        // original font color: 240, 221, 178: #F0DDB2\n        // 252 234 199\n\n        /*  assign color changes here */\n        fontColors.red.src = changeColor(fontImg, {r: 200, g: 50, b: 50}, {r: 252, g: 234, b: 199});\n        fontColors.green.src = changeColor(fontImg, {r: 50, g: 200, b: 50}, {r: 252, g: 234, b: 199});\n\n        imageLoaded = true;\n        textExport.loaded = imageLoaded && dataLoaded;\n        console.log(textExport.loaded);\n    };\n}\n\n\nfunction loadFont() {\n    var oReq = new XMLHttpRequest();\n    oReq.onload = function () {\n        data = JSON.parse(this.responseText);\n\n        lineHeight = data.common.lineHeight;\n\n        for (var i = 0; i < data.chars.length; i++) {\n            fontCache[data.chars[i].id] = {\n                char: data.chars[i],\n                kerning: {}\n            };\n        }\n        for (var j = 0; j < data.kernings.length; j++) {\n            var kern = data.kernings[j];\n            var char = fontCache[kern.first];\n            if (char) {\n                char.kerning[kern.second] = kern.amount;\n            } else {\n                console.log(kern.first);\n            }\n        }\n\n        dataLoaded = true;\n        textExport.loaded = imageLoaded && dataLoaded;\n        console.log(textExport.loaded);\n    };\n    oReq.open(\"get\", \"/font/\" + fontName, true);\n    oReq.send();\n}\n\n\n/**\n * Moves the cursor to the indicated position.\n * @param x\n * @param y\n */\nfunction setCursor(x, y) {\n    cursor.x = x || 0;\n    cursor.y = y || 0;\n}\n\n\nfunction textWidth(text) {\n    if (!textExport.loaded) {\n        console.log(\"text not loaded...\");\n        return;\n    }\n    var width = 0;\n    text = text || '';\n    for (var i = 0; i < text.length; i++) {\n        var char = fontCache[text.charCodeAt(i)].char;\n        width += char.xadvance;\n    }\n    return width;\n}\n","/**\n * Created by john on 3/22/15.\n */\n\n\n'use strict';\n\nfunction isWithin(point, rect) {\n    var x = isBetween(point.x, rect.x, rect.x + rect.w);\n    var y = isBetween(point.y, rect.y, rect.y + rect.h);\n    return x && y;\n\n}\n\nfunction clamp(value, min, max) {\n    return Math.min(max, Math.max(min, value));\n}\n\nfunction isBetween(value, min, max) {\n    return value >= min && value < max;\n}\n\nfunction scaleRect(rect, scale) {\n    //return {\n    //    x: (rect.x * scale),\n    //    y: (rect.y * scale),\n    //    w: Math.floor(rect.w * scale),\n    //    h: (rect.h * scale)\n    //};\n    return rect;\n}\n\n\nfunction distance(p1, p2) {\n    return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);\n}\n\n\nfunction extend() {\n    var defaults = arguments[0];\n    var options = arguments[1];\n\n    var extended = {};\n    if (arguments[2]) {\n        extended = defaults;\n    }\n\n    var prop;\n    for (prop in defaults) {\n        if (Object.prototype.hasOwnProperty.call(defaults, prop)) {\n            extended[prop] = defaults[prop];\n        }\n    }\n    for (prop in options) {\n        if (Object.prototype.hasOwnProperty.call(options, prop)) {\n            extended[prop] = options[prop];\n        }\n    }\n    return extended;\n}\n\n\nmodule.exports = {\n    clamp: clamp,\n    distance: distance,\n    extend: extend,\n    isBetween: isBetween,\n    isWithin: isWithin,\n    scaleRect: scaleRect\n};"]}